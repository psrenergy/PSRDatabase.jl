var documenterSearchIndex = {"docs":
[{"location":"psrdatabase/time_series/#Time-Series","page":"Time Series","title":"Time Series","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"It is possible to store time series data in your database. Time series in PSRDatabase are very flexible. You can have missing values, and you can have sparse data. ","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"There is a specific table format that must be followed. Consider the following example:","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"CREATE TABLE Resource (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL\n) STRICT;\n\nCREATE TABLE Resource_time_series_group1 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    some_vector1 REAL,\n    some_vector2 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time)\n) STRICT; ","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"It is mandatory for a time series to be indexed by a date_time column with the following format: YYYY-MM-DD HH:MM:SS. You can use the Dates.jl package for handling this format.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"using Dates\ndate = DateTime(2024, 3, 1) # 2024-03-01T00:00:00 (March 1st, 2024)","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"Notice that in this example, there are two value columns some_vector1 and some_vector2. You can have as many value columns as you want. You can also separate the time series data into different tables, by creating a table Resource_time_series_group2 for example.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"It is also possible to add more dimensions to your time series, such as block and scenario.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"CREATE TABLE Resource_time_series_group2 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    block INTEGER NOT NULL,\n    some_vector3 REAL,\n    some_vector4 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time, block)\n) STRICT; ","category":"page"},{"location":"psrdatabase/time_series/#Rules","page":"Time Series","title":"Rules","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"Time series in PSRDatabase are very flexible. You can have missing values, and you can have sparse data. ","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"If you are querying for a time series row entry that has a missing value, it first checks if there is a data with a date_time earlier than the queried date_time. If there is, it returns the value of the previous data. If there is no data earlier than the queried date_time, it returns a specified value according to the type of data you are querying.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"For Float64, it returns NaN.\nFor Int64, it returns typemin(Int).\nFor String, it returns \"\" (empty String).\nFor DateTime, it returns typemin(DateTime).","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"For example, if you have the following data:","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"Date some_vector1(Float64) some_vector2(Float64)\n2020 1.0 missing\n2021 missing 1.0\n2022 3.0 missing","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"If you query for some_vector1 at 2020, it returns 1.0. \nIf you query for some_vector2 at 2020, it returns NaN. \nIf you query for some_vector1 at 2021, it returns 1.0. \nIf you query for some_vector2 at 2021, it returns 1.0. \nIf you query for some_vector1 at 2022, it returns 3.0. \nIf you query for some_vector2 at 2022, it returns 1.0.","category":"page"},{"location":"psrdatabase/time_series/#Inserting-data","page":"Time Series","title":"Inserting data","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"When creating a new element that has a time series, you can pass this information via a DataFrame. Consider the collection Resource with the two time series tables Resource_time_series_group1 and Resource_time_series_group2.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"using DataFrames\nusing Dates\nusing PSRDatabase\nPSRDatabase = PSRDatabase.PSRDatabase\n\ndb = PSRDatabase.create_empty_db_from_schema(db_path, path_schema; force = true)\n\nPSRDatabase.create_element!(db, \"Configuration\"; label = \"Toy Case\", value1 = 1.0)\n\ndf_group1 = DataFrame(;\n        date_time = [DateTime(2000), DateTime(2001), DateTime(2002)],\n        some_vector1 = [missing, 1.0, 2.0],\n        some_vector2 = [1.0, missing, 5.0],\n    )\n\ndf_group2 = DataFrame(;\n            date_time = [\n                DateTime(2000),\n                DateTime(2000),\n                DateTime(2000),\n                DateTime(2000),\n                DateTime(2001),\n                DateTime(2001),\n                DateTime(2001),\n                DateTime(2009),\n            ],\n            block = [1, 1, 1, 1, 2, 2, 2, 2],\n            some_vector3 = [1.0, 2.0, 3.0, 4.0, 1, 2, 3, 4],\n            some_vector4 = [1.0, 2.0, 3.0, 4.0, 1, 2, 3, 4],\n        )\n\n\nPSRDatabase.create_element!(\n    db,\n    \"Resource\";\n    label = \"Resource 1\",\n    group1 = df_group1,\n    group2 = df_group2,\n)","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"It is also possible to insert a single row of a time series. This is useful when you want to insert a specific dimension entry. This way of inserting time series is less efficient than inserting a whole DataFrame.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"using DataFrames\nusing Dates\nusing PSRDatabase\nPSRDatabase = PSRDatabase.PSRDatabase\n\ndb = PSRDatabase.create_empty_db_from_schema(db_path, path_schema; force = true)\n\nPSRDatabase.create_element!(db, \"Configuration\"; label = \"Toy Case\", value1 = 1.0)\n\nPSRDatabase.create_element!(\n    db,\n    \"Resource\";\n    label = \"Resource 1\"\n)\n\nPSRDatabase.add_time_series_row!(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    \"Resource 1\",\n    10.0; # new value\n    date_time = DateTime(2000)\n)\n\nPSRDatabase.add_time_series_row!(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    \"Resource 1\",\n    11.0; # new value\n    date_time = DateTime(2001)\n)","category":"page"},{"location":"psrdatabase/time_series/#Reading-data","page":"Time Series","title":"Reading data","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"You can read the information from the time series in two different ways.","category":"page"},{"location":"psrdatabase/time_series/#Reading-as-a-table","page":"Time Series","title":"Reading as a table","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"First, you can read the whole time series table for a given value, as a DataFrame.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"df = PSRDatabase.read_time_series_table(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    \"Resource 1\",\n)","category":"page"},{"location":"psrdatabase/time_series/#Reading-a-single-row","page":"Time Series","title":"Reading a single row","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"It is also possible to read a single row of the time series in the form of an array. This is useful when you want to query a specific dimension entry. For this function, there are performance improvements when reading the data via caching the previous and next non-missing values. ","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"values = PSRDatabase.read_time_series_row(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    Float64;\n    date_time = DateTime(2020)\n)","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"When querying a row, all values should non-missing. However, if there is a missing value, the function will return the previous non-missing value. And if even the previous value is missing, it will return a specified value according to the type of data you are querying.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"For Float64, it returns NaN.\nFor Int64, it returns typemin(Int).\nFor String, it returns \"\" (empty String).\nFor DateTime, it returns typemin(DateTime).","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"For example, if you have the following data for the time series some_vector1:","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"Date Resource 1 Resource 2\n2020 1.0 missing\n2021 missing 1.0\n2022 3.0 missing","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"If you query at 2020, it returns [1.0, NaN]. \nIf you query at 2021, it returns [1.0, 1.0]. \nIf you query at 2022, it returns [3.0, 1.0]. ","category":"page"},{"location":"psrdatabase/time_series/#Updating-data","page":"Time Series","title":"Updating data","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"When updating one of the entries of a time series for a given element and attribute, you need to specify the exact dimension values of the row you want to update. ","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"For example, consider a time series that has block and data_time dimensions.","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"PSRDatabase.update_time_series_row!(\n    db,\n    \"Resource\",\n    \"some_vector3\",\n    \"Resource 1\",\n    10.0; # new value\n    date_time = DateTime(2000),\n    block = 1\n)","category":"page"},{"location":"psrdatabase/time_series/#Deleting-data","page":"Time Series","title":"Deleting data","text":"","category":"section"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"You can delete the whole time series of an element for a given time series group. Consider the following table:","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"CREATE TABLE Resource_time_series_group1 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    some_vector1 REAL,\n    some_vector2 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time)\n) STRICT; ","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"This table represents a \"group\" that stores two time series some_vector1 and some_vector2. You can delete all the data from this group by calling the following function:","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"PSRDatabase.delete_time_series!(\n    db,\n    \"Resource\",\n    \"group1\",\n    \"Resource 1\",\n)","category":"page"},{"location":"psrdatabase/time_series/","page":"Time Series","title":"Time Series","text":"When trying to read a time series that has been deleted, the function will return an empty DataFrame.","category":"page"},{"location":"psrdatabase/rules/#PSRDatabase","page":"PSRDatabase","title":"PSRDatabase","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Following PSRI's OpenStudy standards, SQL schemas for the PSRDatabase framework should follow the conventions described in this document. Note that this is a tool for creating and developing some kinds of applications. Not all tools will need to use this framework.","category":"page"},{"location":"psrdatabase/rules/#SQL-Schema-Conventions","page":"PSRDatabase","title":"SQL Schema Conventions","text":"","category":"section"},{"location":"psrdatabase/rules/#Collections","page":"PSRDatabase","title":"Collections","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"The Table name should be the same as the name of the Collection.\nThe Table name of a Collection should beging with a capital letter and be in singular form.\nIn case of a Collection with a composite name, the Table name should written in Pascal Case.\nThe Table must contain a primary key named id that is an INTEGER. You should use the AUTOINCREMENT keyword to automatically generate the id for each element.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Examples:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE Resource (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    some_type TEXT\n) STRICT;\n\nCREATE TABLE ThermalPlant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    minimum_generation REAL DEFAULT 0\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/#Configuration-collection","page":"PSRDatabase","title":"Configuration collection","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Every database definition must have a Configuration, which will store information from the case.  The column label is not mandatory for a Configuration collection.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE Configuration (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    value1 REAL NOT NULL DEFAULT 100,\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/#Non-vector-Attributes","page":"PSRDatabase","title":"Non-vector Attributes","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"The name of an Attribute should be in snake case and be in singular form.\nIf the attribute's name is label, it should be stored as a TEXT and have the UNIQUE and NOT NULL constraints.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE ThermalPlant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    minimum_generation REAL NOT NULL\n    some_example_of_attribute REAL\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"If an attribute name starts with date it should be stored as a TEXT and indicates a date that will be mapped to a DateTime object.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE ThermalPlant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    minimum_generation REAL NOT NULL,\n    date_of_construction TEXT\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"If an attribute name starts with the name of another collection it should be stored as a INTEGER and indicates a relation with another collection. It should never have the NOT NULL constraint. All references should always declare the ON UPDATE CASCADE ON DELETE CASCADE constraint. In the example below the attribute gaugingstation_id indicates that the collection Plant has an id relation with the collection GaugingStation and the attribute plant_spill_to indicates that the collection Plant has a spill_to relation with itself.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE Plant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    gaugingstation_id INTEGER,\n    plant_spill_to INTEGER,\n    FOREIGN KEY(gaugingstation_id) REFERENCES GaugingStation(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    FOREIGN KEY(plant_spill_to) REFERENCES Plant(id) ON UPDATE SET NULL ON DELETE CASCADE\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/#Vector-Attributes","page":"PSRDatabase","title":"Vector Attributes","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"In case of a vector attribute, a table should be created with its name indicating the name of the Collection and the name of a group of the attribute, separated by _vector_, such as COLLECTION_vector_GROUP_OF_ATTRIBUTES.\nThe table must contain a Column named id and another named vector_index.\nThere must be a Column named after the attributes names, which will store the value of the attribute for the specified element id and index vector_index.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"These groups are used to store vectors that should have the same size. If two vectors don't necessarily have the same size, they should be stored in different groups.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE ThermalPlant_vector_some_group(\n    id INTEGER,\n    vector_index INTEGER NOT NULL,\n    some_value REAL NOT NULL,\n    some_other_value REAL,\n    FOREIGN KEY (id) REFERENCES ThermalPlant(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    PRIMARY KEY (id, vector_index)\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example of a small time series","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE ThermalPlant_vector_some_group(\n    id INTEGER,\n    vector_index INTEGER NOT NULL,\n    date_of_modification REAL NOT NULL,\n    capacity REAL,\n    FOREIGN KEY (id) REFERENCES ThermalPlant(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    PRIMARY KEY (id, vector_index)\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"A vector relation with another collection should be stored in a table of vector groups and be defined the same way as a vector attribute. To tell that it is a relation with another collection, the name of the relational attribute should be the name of the target collection followed by the relation type defined as _relation_type, i.e. gaugingstation_id indicated that the collection HydroPlant has an id relation with the collection GaugingStation. If the name of the attribute was gaugingstation_one_to_one, it would indicate that the collection HydroPlant has a relation one_to_one with the collection GaugingStation.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE HydroPlant_vector_GaugingStation(\n    id INTEGER,\n    vector_index INTEGER NOT NULL,\n    conversion_factor REAL NOT NULL,\n    gaugingstation_id INTEGER,\n    FOREIGN KEY (gaugingstation_id) REFERENCES GaugingStation(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    PRIMARY KEY (id, vector_index)\n) STRICT;\n","category":"page"},{"location":"psrdatabase/rules/#Time-Series-Files","page":"PSRDatabase","title":"Time Series Files","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"All Time Series files for the elements from a Collection should be stored in a Table\nThe Table name should be the same as the name of the Collection followed by _time_series_files, such as COLLECTION_vector_ATTRIBUTE.\nEach Column of the table should be named after the name of the attribute.\nEach Column should store the path to the file containing the time series data.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE Plant_time_series_files (\n    generation TEXT,\n    cost TEXT\n) STRICT;","category":"page"},{"location":"psrdatabase/rules/#Time-Series","page":"PSRDatabase","title":"Time Series","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Time Series stored in the database should be stored in a table with the name of the Collection followed by _time_series_ and the name of the attribute group, such a COLLECTION_time_series_GROUP_OF_ATTRIBUTES.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Notice that it is quite similar to the vector attributes, but without the vector_index column. Instead, a mandatory column named date_time should be created to store the date of the time series data.","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Example:","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"CREATE TABLE Resource_time_series_group1 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    some_vector1 REAL,\n    some_vector2 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time)\n) STRICT; ","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"tip: Tip\n","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"For more information on how to handle time series data, please refer to the Time Series section.","category":"page"},{"location":"psrdatabase/rules/#Migrations","page":"PSRDatabase","title":"Migrations","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"Migrations are an important part of the DatabaseSQLite framework. They are used to update the database schema to a new version without the need to delete the database and create a new one from scratch. Migrations are defined by two separate .sql files that are stored in the migrations directory of the model. The first file is the up migration and it is used to update the database schema to a new version. The second file is the down migration and it is used to revert the changes made by the up migration. Migrations are stored in directories in the model and they have a specific naming convention. The name of the migration folder should be the number of the version (e.g. /migrations/1/).","category":"page"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"database/migrations\n├── 1\n│   ├── up.sql\n│   └── down.sql\n└── 2\n    ├── up.sql\n    └── down.sql","category":"page"},{"location":"psrdatabase/rules/#Creating-a-migration","page":"PSRDatabase","title":"Creating a migration","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"It is advised to create new migrations using the functions from DatabaseSQLite. First you need to make sure that the migrations directory is registered  by the function DatabaseSQLite.set_migrations_folder and after that you can create a new migration using the function DatabaseSQLite.create_migration. This function will create a new migration file with the name and version specified by the user. The migration file will contain a template for the migration.","category":"page"},{"location":"psrdatabase/rules/#Running-migrations","page":"PSRDatabase","title":"Running migrations","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"To run migrations you need to use the function DatabaseSQLite.apply_migrations!. There are various versions of this function, each one tailored to make something easier for the user.","category":"page"},{"location":"psrdatabase/rules/#Testing-migrations","page":"PSRDatabase","title":"Testing migrations","text":"","category":"section"},{"location":"psrdatabase/rules/","page":"PSRDatabase","title":"PSRDatabase","text":"It is very important to test if the migrations of a certain model are working as expected, so the user can be sure that the database schema is updated correctly. To test migrations you need to use the function DatabaseSQLite.test_migrations(). It is highly advised that each model has one of these functions in their test suite to make sure that the migrations are working as expected.","category":"page"},{"location":"sqlite_examples/migrations/#Migration-Examples","page":"Migration Examples","title":"Migration Examples","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Migrations are a way to manage the evolution of the database schema over time. As mentioned in the documentation for PSRDatabase, migrations are defined by two separate .sql files that are stored in the migrations directory of the model. The first file is the up migration and it is used to update the database schema to a new version. The second file is the down migration and it is used to revert the changes made by the up migration. Migrations are stored in directories in the model and they have a specific naming convention. The name of the migration folder should be the number of the version (e.g. /migrations/1/).","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"In this section, we will provide some examples of migrations. First, let us start with the first migration, the one that creates the initial database schema.","category":"page"},{"location":"sqlite_examples/migrations/#Adding-two-tables-to-the-database","page":"Migration Examples","title":"Adding two tables to the database","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 1; -- Set the database version to 1\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the Configuration table\nCREATE TABLE Configuration (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    value TEXT NOT NULL\n) ;\n\n-- Create Plant table\nCREATE TABLE Plant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL\n) ;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This schema is the up.sql migration for version 1. It creates two tables, Configuration and Plant. Now we have to create the down.sql migration for version 1. This migration should drop the tables created in the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 0; -- Set the database version to 0\n-- Drop the Configuration table\nDROP TABLE Configuration;\n-- Drop the Plant table\nDROP TABLE Plant;","category":"page"},{"location":"sqlite_examples/migrations/#Adding-a-new-column","page":"Migration Examples","title":"Adding a new column","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Now let us create a migration that adds a new column to the Configuration and Plant tables.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 2; -- Set the database version to 2\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Add the description column to the Configuration table\nALTER TABLE Configuration ADD COLUMN description TEXT;\n\n-- Add the type column to the Plant table\nALTER TABLE Plant ADD COLUMN type INTEGER NOT NULL DEFAULT 0;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 2. The down.sql migration should remove the column added in the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 1; -- Set the database version to 1\n\n-- Remove the description column from the Configuration table\nALTER TABLE Configuration DROP COLUMN description;\n\n-- Remove the type column from the Plant table\nALTER TABLE Plant DROP COLUMN type;","category":"page"},{"location":"sqlite_examples/migrations/#Renaming-a-table","page":"Migration Examples","title":"Renaming a table","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that renames the Plant table to PowerPlant.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 3; -- Set the database version to 3\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Rename the Plant table to PowerPlant\nALTER TABLE Plant RENAME TO PowerPlant;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 3. The down.sql migration should rename the PowerPlant table back to Plant.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 2; -- Set the database version to 2\n\n-- Rename the PowerPlant table to Plant\nALTER TABLE PowerPlant RENAME TO Plant;","category":"page"},{"location":"sqlite_examples/migrations/#Adding-a-foreign-key-constraint","page":"Migration Examples","title":"Adding a foreign key constraint","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that adds a foreign key constraint to the PowerPlant table. First, we need to create a new table, Resource, that will be referenced by the PowerPlant table.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Adding a foreign key constraint, however, is not as trivial as adding a column or renaming a table. We need to follow these steps:","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Disable foreign key constraints\nStart a transaction\nCreate an auxiliary new_PowerPlant table with the new column and the foreign key constraint\nCopy the data from the PowerPlant table to the new_PowerPlant table\nDrop the PowerPlant table\nRename the new_PowerPlant table to PowerPlant\nCheck if any foreign key constraints were violatet with PRAGMA foreign_key_check\nCommit the transaction\nEnable foreign key constraints ","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 4; -- Set the database version to 4\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the Resource table\nCREATE TABLE Resource (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL\n) ;\n\n-- Disable foreign key constraints\nPRAGMA foreign_keys = OFF;\n\n-- Start a transaction\nBEGIN TRANSACTION;\n\n-- Create the new PowerPlant table\nCREATE TABLE new_PowerPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    type INTEGER NOT NULL DEFAULT 0,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Copy the data from the PowerPlant table to the new PowerPlant table\nINSERT INTO new_PowerPlant (id, label, capacity, bus_name, type)\nSELECT id, label, capacity, bus_name, type FROM PowerPlant;\n\n-- Drop the PowerPlant table\nDROP TABLE PowerPlant;\n\n-- Rename the new PowerPlant table to PowerPlant\nALTER TABLE new_PowerPlant RENAME TO PowerPlant;\n\n-- Check if any foreign key constraints were violated\nPRAGMA foreign_key_check;\n\n-- Commit the transaction\nCOMMIT;\n\n-- Enable foreign key constraints\nPRAGMA foreign_keys = ON;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Now, the down.sql migration should revert the changes made by the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 3; -- Set the database version to 3\n\n-- Disable foreign key constraints\nPRAGMA foreign_keys = OFF;\n\n-- Start a transaction\nBEGIN TRANSACTION;\n\n-- Create the new PowerPlant table\nCREATE TABLE new_PowerPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    type INTEGER NOT NULL DEFAULT 0\n) ;\n\n-- Copy the data from the PowerPlant table to the new PowerPlant table\nINSERT INTO new_PowerPlant (id, label, capacity, bus_name, type)\nSELECT id, label, capacity, bus_name, type FROM PowerPlant;\n\n-- Drop the PowerPlant table\nDROP TABLE PowerPlant;\n\n-- Rename the new PowerPlant table to PowerPlant\nALTER TABLE new_PowerPlant RENAME TO PowerPlant;\n\n-- Check if any foreign key constraints were violated\nPRAGMA foreign_key_check;\n\n-- Commit the transaction\nCOMMIT;\n\n-- Enable foreign key constraints\nPRAGMA foreign_keys = ON;\n\n-- Drop the Resource table\nDROP TABLE Resource;","category":"page"},{"location":"sqlite_examples/migrations/#Dividing-a-table-into-two-tables","page":"Migration Examples","title":"Dividing a table into two tables","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that divides the PowerPlant table into two tables, HydroPlant and ThermalPlant.  HydroPlant corresponds to the rows with type = 0 and ThermalPlant corresponds to the rows with type = 1.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 5; -- Set the database version to 5\n\n\n\nPRAGMA foreign_keys = OFF;\nBEGIN TRANSACTION;\n\n-- Create the HydroPlant table\nCREATE TABLE HydroPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Create the ThermalPlant table\nCREATE TABLE ThermalPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Fill the HydroPlant table\nINSERT INTO HydroPlant (id, label, capacity, bus_name, resource_id)\nSELECT id, label, capacity, bus_name, resource_id FROM PowerPlant WHERE type = 0;\n\n-- Fill the ThermalPlant table\nINSERT INTO ThermalPlant (id, label, capacity, bus_name, resource_id)\nSELECT id, label, capacity, bus_name, resource_id FROM PowerPlant WHERE type = 1;\n\n-- Drop the PowerPlant table\nDROP TABLE PowerPlant;\n\nPRAGMA foreign_key_check;\nCOMMIT;\nPRAGMA foreign_keys = ON;\n","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 5. The down.sql migration should revert the changes made by the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 4; -- Set the database version to 4\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the PowerPlant table\nCREATE TABLE PowerPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    type INTEGER NOT NULL DEFAULT 0,\n    bus_name TEXT NOT NULL,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Fill the PowerPlant table\nINSERT INTO PowerPlant (id, label, capacity, bus_name, type, resource_id)\nSELECT id, label, capacity, bus_name, 0, resource_id FROM HydroPlant;\n\nINSERT INTO PowerPlant (id, label, capacity, bus_name, type, resource_id)\nSELECT id, label, capacity, bus_name, 1, resource_id FROM ThermalPlant;\n\n-- Drop the HydroPlant table\nDROP TABLE HydroPlant;\n\n-- Drop the ThermalPlant table\nDROP TABLE ThermalPlant;","category":"page"},{"location":"sqlite_examples/migrations/#Create-a-table-with-data-from-another-table","page":"Migration Examples","title":"Create a table with data from another table","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that adds a new Table Bus with data from the HydroPlant and ThermalPlant tables. These tables already have a column bus_name that will be used to fill the Bus table. After creating the Bus table, we will remove the bus_name column from the HydroPlant and ThermalPlant tables. Moreover, the bus_name column in the PowerPlant table will be replaced by a bus_id column that references the Bus table.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 6; -- Set the database version to 6\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the Bus table\nCREATE TABLE Bus (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL\n) ;\n\n-- Fill the Bus table\nINSERT INTO Bus (label)\nSELECT DISTINCT bus_name FROM HydroPlant;\n\nINSERT INTO Bus (label)\nSELECT DISTINCT bus_name FROM ThermalPlant;\n\nPRAGMA foreign_keys = OFF;\nBEGIN TRANSACTION;\n\n-- Add foreign key \nCREATE TABLE new_HydroPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    FOREIGN KEY (bus_id) REFERENCES Bus(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\nCREATE TABLE new_ThermalPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    FOREIGN KEY (bus_id) REFERENCES Bus(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Copy the data from the HydroPlant table to the new HydroPlant table\nINSERT INTO new_HydroPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM HydroPlant;\n\n-- Copy the data from the ThermalPlant table to the new ThermalPlant table\nINSERT INTO new_ThermalPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM ThermalPlant;\n\n-- Add data for the bus_id column\nUPDATE new_HydroPlant SET bus_id = (SELECT Bus.id FROM Bus\nINNER JOIN HydroPlant ON Bus.label = HydroPlant.bus_name AND \nHydroPlant.id = new_HydroPlant.id\n);\nUPDATE new_ThermalPlant SET bus_id = (SELECT Bus.id FROM Bus\nINNER JOIN ThermalPlant ON Bus.label = ThermalPlant.bus_name AND\nThermalPlant.id = new_ThermalPlant.id\n);\n\n-- Drop tables\nDROP TABLE HydroPlant;\nDROP TABLE ThermalPlant;\n\n-- Rename tables\nALTER TABLE new_HydroPlant RENAME TO HydroPlant;\nALTER TABLE new_ThermalPlant RENAME TO ThermalPlant;\n\nPRAGMA foreign_key_check;\nCOMMIT;\nPRAGMA foreign_keys = ON;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 6. The down.sql migration should revert the changes made by the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 5; -- Set the database version to 5\n\n\nPRAGMA foreign_keys = OFF;\nBEGIN TRANSACTION;\n\n-- Create auxiliary tables\nCREATE TABLE new_HydroPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_name TEXT,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\nCREATE TABLE new_ThermalPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_name TEXT,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Copy the data from the HydroPlant table to the new HydroPlant table\nINSERT INTO new_HydroPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM HydroPlant;\n\n-- Copy the data from the ThermalPlant table to the new ThermalPlant table\nINSERT INTO new_ThermalPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM ThermalPlant;\n\n-- Add data for the bus_name column\nUPDATE new_HydroPlant SET bus_name = (SELECT Bus.label FROM Bus\nINNER JOIN HydroPlant ON Bus.id = HydroPlant.bus_id AND \nHydroPlant.id = new_HydroPlant.id\n);\n\nUPDATE new_ThermalPlant SET bus_name = (SELECT Bus.label FROM Bus\nINNER JOIN ThermalPlant ON Bus.id = ThermalPlant.bus_id AND\nThermalPlant.id = new_ThermalPlant.id\n);\n\n-- Drop tables\nDROP TABLE HydroPlant;\nDROP TABLE ThermalPlant;\n\n-- Rename tables\nALTER TABLE new_HydroPlant RENAME TO HydroPlant;\nALTER TABLE new_ThermalPlant RENAME TO ThermalPlant;\n\n-- Drop the Bus table\nDROP TABLE Bus;\n\nPRAGMA foreign_key_check;\nCOMMIT;\nPRAGMA foreign_keys = ON;","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The PSRDatabase module provides interfaces to access data structured by PSR to be used in its models. Currently there are two main interfaces. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interface for studies. This interface is designed to read parameters from the files, some examples are deficit costs, fuel costs, currency, storage capacity etc.\nThe interface for reading and writing time series data. Time series data in the context of most studies have 4 dimensions (agents, stages, scenarios and blocks). Since studies of renewables with multiple agents, scenarios and stages can get quite big, we have designed different formats that are optimized to some objective (human readability, size, fast reading and writing, etc.).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both interfaces are defined as a set of methods that need to be implemented to make a different file format work. In this manual we will describe the abstract methods and give concrete examples of code to perform the work needed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When using the PSRDatabase package in your codebase we strongly advise you to create a constant PSRI to keep the code concise and explicitly declare that a certain function came from PSRDatabase. This can be done by adding the following code to the top of the code","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using PSRDatabase\nconst PSRI = PSRDatabase","category":"page"},{"location":"manual/#Initialize-Study","page":"Manual","title":"Initialize Study","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.AbstractData\nPSRDatabase.AbstractStudyInterface\nPSRDatabase.load_study\nPSRDatabase.description\nPSRDatabase.max_elements","category":"page"},{"location":"manual/#Study-dimensions","page":"Manual","title":"Study dimensions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.StageType\nPSRDatabase.total_stages\nPSRDatabase.total_scenarios\nPSRDatabase.total_blocks\nPSRDatabase.total_openings\nPSRDatabase.total_stages_per_year","category":"page"},{"location":"manual/#Study-duration-and-blocking","page":"Manual","title":"Study duration and blocking","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.BlockDurationMode\nPSRDatabase.stage_duration\nPSRDatabase.block_duration\nPSRDatabase.block_from_stage_hour","category":"page"},{"location":"manual/#Read-Scalar-Attributes","page":"Manual","title":"Read Scalar Attributes","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.configuration_parameter\nPSRDatabase.get_code\nPSRDatabase.get_name\nPSRDatabase.get_parm\nPSRDatabase.get_parm_1d\nPSRDatabase.get_parms\nPSRDatabase.get_parms_1d","category":"page"},{"location":"manual/#Read-Vector-Attributes","page":"Manual","title":"Read Vector Attributes","text":"","category":"section"},{"location":"manual/#Time-controller","page":"Manual","title":"Time controller","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.mapped_vector\nPSRDatabase.go_to_stage\nPSRDatabase.go_to_dimension\nPSRDatabase.update_vectors!","category":"page"},{"location":"manual/#Direct-access","page":"Manual","title":"Direct access","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.get_vector\nPSRDatabase.get_vector_1d\nPSRDatabase.get_vector_2d\nPSRDatabase.get_vectors\nPSRDatabase.get_vectors_1d\nPSRDatabase.get_vectors_2d\nPSRDatabase.get_nonempty_vector\nPSRDatabase.get_series","category":"page"},{"location":"manual/#Relations-between-collections","page":"Manual","title":"Relations between collections","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.RelationType\nPSRDatabase.is_vector_relation\nPSRDatabase.get_references\nPSRDatabase.get_vector_references\nPSRDatabase.get_map\nPSRDatabase.get_vector_map\nPSRDatabase.get_reverse_map\nPSRDatabase.get_reverse_vector_map\nPSRDatabase.get_related\nPSRDatabase.get_vector_related","category":"page"},{"location":"manual/#Reflection","page":"Manual","title":"Reflection","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.get_attribute_dim1\nPSRDatabase.get_attribute_dim2\nPSRDatabase.get_collections\nPSRDatabase.get_attributes\nPSRDatabase.get_attribute_struct\nPSRDatabase.get_data_struct\nPSRDatabase.Attribute\nPSRDatabase.get_attributes_indexed_by\nPSRDatabase.get_relations\nPSRDatabase.get_attribute_dim","category":"page"},{"location":"manual/#PSRDatabase.Attribute","page":"Manual","title":"PSRDatabase.Attribute","text":"Attribute\n\nAbstract type for attributes, the building blocks of collections.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Read-and-Write-Graf-files","page":"Manual","title":"Read and Write Graf files","text":"","category":"section"},{"location":"manual/#Open-and-Close","page":"Manual","title":"Open and Close","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.AbstractReader\nPSRDatabase.AbstractWriter\nPSRDatabase.open\nPSRDatabase.close","category":"page"},{"location":"manual/#Write-entire-file","page":"Manual","title":"Write entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.array_to_file","category":"page"},{"location":"manual/#Write-registry","page":"Manual","title":"Write registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.write_registry","category":"page"},{"location":"manual/#Header-information","page":"Manual","title":"Header information","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.is_hourly\nPSRDatabase.hour_discretization\nPSRDatabase.max_stages\nPSRDatabase.max_scenarios\nPSRDatabase.max_blocks\nPSRDatabase.max_blocks_current\nPSRDatabase.max_blocks_stage\nPSRDatabase.max_agents\nPSRDatabase.stage_type\nPSRDatabase.initial_stage\nPSRDatabase.initial_year\nPSRDatabase.data_unit\nPSRDatabase.agent_names","category":"page"},{"location":"manual/#Read-entire-file","page":"Manual","title":"Read entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.file_to_array\nPSRDatabase.file_to_array_and_header","category":"page"},{"location":"manual/#Read-registry","page":"Manual","title":"Read registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.current_stage\nPSRDatabase.current_scenario\nPSRDatabase.current_block\nPSRDatabase.goto\nPSRDatabase.next_registry","category":"page"},{"location":"manual/#File-conversion","page":"Manual","title":"File conversion","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.convert_file\nPSRDatabase.add_reader!","category":"page"},{"location":"manual/#Reader-mapper","page":"Manual","title":"Reader mapper","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.ReaderMapper\nPSRDatabase.add_reader!\n<!-- PSRDatabase.goto -->\nPSRDatabase.close","category":"page"},{"location":"manual/#Modification-API","page":"Manual","title":"Modification API","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRDatabase.create_study\nPSRDatabase.create_element!\nPSRDatabase.set_parm!\nPSRDatabase.set_vector!\nPSRDatabase.set_series!\nPSRDatabase.write_data\nPSRDatabase.set_related!\nPSRDatabase.set_vector_related!","category":"page"},{"location":"psrdatabase/introduction/#SQLite-101","page":"SQLite 101","title":"SQLite 101","text":"","category":"section"},{"location":"psrdatabase/introduction/","page":"SQLite 101","title":"SQLite 101","text":"SQLite is a software library that provides a relational database management system. The lite in SQLite means light weight in terms of setup, database administration, and required resource. SQLite does NOT require a server to run.","category":"page"},{"location":"psrdatabase/introduction/","page":"SQLite 101","title":"SQLite 101","text":"To learn the basics, we recommend the following resources:","category":"page"},{"location":"psrdatabase/introduction/","page":"SQLite 101","title":"SQLite 101","text":"SQLite Tutorial\nSQLite Documentation","category":"page"},{"location":"psrdatabase/introduction/","page":"SQLite 101","title":"SQLite 101","text":"tip: Tip\nWe recommend using SQLiteStudio to debug and visualize your SQLite database. You can download it here.","category":"page"},{"location":"#PSRDatabase-Documentation","page":"Home","title":"PSRDatabase Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PSRDatabase, or PSRI, is a Julia package that provides an interface to read and write open-source formats for PSR models. It is comprised of three main modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenStudy: Reads and writes data in the JSON format\nOpenBinary: Reads and writes time series data in the binary format\nPSRDatabase: Reads and writes data in the SQL format","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered so you can simply add it using Julia's Pkg manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"PSRDatabase\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users are encouraged to contributing by opening issues and opening pull requests. If you wish to implement a feature please follow  the JuMP Style Guide","category":"page"}]
}
