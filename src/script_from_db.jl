"""
    generate_julia_script_from_database(db::DatabaseSQLite, output_jl_path::String, output_db_path::String; path_schema::String = "", path_migrations::String = "")

Generate Julia code that recreates a database using PSRDatabase.jl functions.

This function introspects an existing database and generates code using `create_element!`,
`set_vector_relation!`, `set_scalar_relation!`, and time series functions to recreate
the database content.

# Arguments

  - `db::DatabaseSQLite`: The database to generate code from
  - `output_jl_path::String`: Path to write the generated code
  - `output_db_path::String`: Path of the database to be created in the generated code
  - `path_schema::String`: Optional path to a schema file to create the empty database
  - `path_migrations::String`: Optional path to a migrations folder to create the empty database
"""
function generate_julia_script_from_database(
    db::DatabaseSQLite,
    output_jl_path::String,
    output_db_path::String;
    path_schema::String = "",
    path_migrations::String = "",
)
    code_lines = String[]
    relation_lines = String[]

    msg_error = ""
    if !isempty(output_jl_path) && !isdir(dirname(output_jl_path))
        msg_error *= "output_jl_path directory path is invalid.\n"
    end
    if !isempty(output_db_path) && !isdir(dirname(output_db_path))
        msg_error *= "output_db_path directory path is invalid.\n"
    end
    if !isempty(path_schema) && !isempty(path_migrations)
        msg_error *= "Specify either path_schema or path_migrations, not both.\n"
    end
    if isempty(path_schema) && isempty(path_migrations)
        msg_error *= "Specify either path_schema or path_migrations.\n"
    end
    if !isempty(msg_error)
        psr_database_sqlite_error(msg_error)
    end

    push!(code_lines, "# Auto-generated code to recreate database")
    push!(code_lines, "# Generated by PSRDatabase.generate_julia_script_from_database")
    push!(code_lines, "")
    push!(code_lines, "using PSRDatabase")
    push!(code_lines, "using DataFrames")
    push!(code_lines, "using Dates")
    push!(code_lines, "")
    if !isempty(path_schema)
        push!(code_lines, "db = PSRDatabase.create_empty_db_from_schema(raw\"$output_db_path\", raw\"$path_schema\"; force = true)")
    end
    if !isempty(path_migrations)
        push!(code_lines, "db = PSRDatabase.create_empty_db_from_migrations(raw\"$output_db_path\", raw\"$path_migrations\"; force = true)")
    end
    push!(code_lines, "")

    collection_ids = _get_collection_ids(db)

    for collection_id in collection_ids
        push!(code_lines, "# Collection: $collection_id")
        collection_code, collection_relations = _generate_collection_code(db, collection_id)
        push!(code_lines, collection_code)
        push!(code_lines, "")

        if !isempty(collection_relations)
            append!(relation_lines, collection_relations)
        end
    end

    # Add relations section at the end
    if !isempty(relation_lines)
        push!(code_lines, "# Setting relations")
        append!(code_lines, relation_lines)
    end

    # Close db
    push!(code_lines, "")
    push!(code_lines, "# Close the database")
    push!(code_lines, "PSRDatabase.close!(db)")
    push!(code_lines, "")

    generated_code = join(code_lines, "\n")

    open(output_jl_path, "w") do io
        return write(io, generated_code)
    end
    return nothing
end

"""
    _generate_collection_code(db::DatabaseSQLite, collection_id::String)

Generate code for all elements in a collection.
Returns a tuple of (element_creation_code, relation_code).
"""
function _generate_collection_code(db::DatabaseSQLite, collection_id::String)
    code_lines = String[]
    relation_lines = String[]

    num_elements = number_of_elements(db, collection_id)
    if num_elements == 0
        push!(code_lines, "# No elements in $collection_id")
        return join(code_lines, "\n"), relation_lines
    end

    collection = _get_collection(db, collection_id)

    # Get all element IDs and labels
    element_ids = _read_all_ids(db, collection_id)
    labels = _read_all_labels(db, collection_id)

    for (idx, (element_id, label)) in enumerate(zip(element_ids, labels))
        if idx > 1
            push!(code_lines, "")
        end
        element_code, element_relations = _generate_element_code(db, collection, element_id, label)
        push!(code_lines, element_code)

        if !isempty(element_relations)
            append!(relation_lines, element_relations)
        end
    end

    return join(code_lines, "\n"), relation_lines
end

"""
    _generate_element_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code to create a single element with all its attributes.
Returns a tuple of (element_creation_code, relation_code).
"""
function _generate_element_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]
    relation_lines = String[]
    collection_id = collection.id

    push!(code_lines, "PSRDatabase.create_element!(")
    push!(code_lines, "    db,")
    push!(code_lines, "    \"$collection_id\";")

    # Generate scalar parameters
    scalar_params = _generate_scalar_parameters_code(db, collection, element_id, label)
    append!(code_lines, scalar_params)

    # Generate vector parameters (grouped)
    vector_params = _generate_vector_parameters_code(db, collection, element_id)
    append!(code_lines, vector_params)

    # Generate set parameters (grouped)
    set_params = _generate_set_parameters_code(db, collection, element_id)
    append!(code_lines, set_params)

    # Generate time series
    time_series_params = _generate_time_series_parameters_code(db, collection, element_id)
    append!(code_lines, time_series_params)

    push!(code_lines, ")")

    # Generate time series files (immediately after element creation)
    time_series_files = _generate_time_series_files_code(db, collection, element_id, label)
    if !isempty(time_series_files)
        push!(code_lines, "")
        append!(code_lines, time_series_files)
    end

    # Collect scalar relations to be set at the end
    scalar_relations = _generate_scalar_relations_code(db, collection, element_id, label)
    if !isempty(scalar_relations)
        append!(relation_lines, scalar_relations)
    end

    # Collect vector relations to be set at the end
    vector_relations = _generate_vector_relations_code(db, collection, element_id, label)
    if !isempty(vector_relations)
        append!(relation_lines, vector_relations)
    end

    # Collect set relations to be set at the end
    set_relations = _generate_set_relations_code(db, collection, element_id, label)
    if !isempty(set_relations)
        append!(relation_lines, set_relations)
    end

    # Collect time series relations to be set at the end
    time_series_relations = _generate_time_series_relations_code(db, collection, element_id, label)
    if !isempty(time_series_relations)
        append!(relation_lines, time_series_relations)
    end

    return join(code_lines, "\n"), relation_lines
end

"""
    _generate_scalar_parameters_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code for scalar parameters of an element.
"""
function _generate_scalar_parameters_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]

    for (attr_id, attr) in collection.scalar_parameters
        if attr_id == "id"
            continue
        end

        value = _read_scalar_value_by_id(db, collection.id, attr_id, element_id)

        if attr_id == "label" || !ismissing(value) && !_is_null_in_db(value)
            formatted_value = _format_value(value, attr.type)
            push!(code_lines, "    $attr_id = $formatted_value,")
        end
    end

    return code_lines
end

"""
    _generate_vector_parameters_code(db::DatabaseSQLite, collection::Collection, element_id::Int)

Generate code for vector parameters grouped by their group_id.
"""
function _generate_vector_parameters_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
)
    code_lines = String[]

    # Group vector parameters by group_id
    groups_map = _map_of_groups_to_vector_attributes(db, collection.id)

    for (group_id, attr_ids) in groups_map
        # Only get parameter attributes (not relations)
        param_attrs = String[]
        for attr_id in attr_ids
            if haskey(collection.vector_parameters, attr_id)
                push!(param_attrs, attr_id)
            end
        end

        if isempty(param_attrs)
            continue
        end

        # Read vector data for this group
        vector_data = _read_vector_group_data(db, collection.id, group_id, element_id)

        if isempty(vector_data)
            continue
        end

        # Generate array literal for each attribute
        for attr_id in param_attrs
            if haskey(vector_data, attr_id)
                values = vector_data[attr_id]
                # Only include the vector if it has at least one non-null value
                if any(!_is_null_in_db(v) for v in values)
                    formatted_values = _format_vector(values, collection.vector_parameters[attr_id].type)
                    push!(code_lines, "    $attr_id = $formatted_values,")
                end
            end
        end
    end

    return code_lines
end

"""
    _generate_set_parameters_code(db::DatabaseSQLite, collection::Collection, element_id::Int)

Generate code for set parameters grouped by their group_id.
"""
function _generate_set_parameters_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
)
    code_lines = String[]

    # Group set parameters by group_id
    groups_map = _map_of_groups_to_set_attributes(db, collection.id)

    for (group_id, attr_ids) in groups_map
        # Only get parameter attributes (not relations)
        param_attrs = String[]
        for attr_id in attr_ids
            if haskey(collection.set_parameters, attr_id)
                push!(param_attrs, attr_id)
            end
        end

        if isempty(param_attrs)
            continue
        end

        # Read set data for this group
        set_data = _read_set_group_data(db, collection.id, group_id, element_id)

        if isempty(set_data)
            continue
        end

        # Generate Set literal for each attribute
        for attr_id in param_attrs
            if haskey(set_data, attr_id)
                values = set_data[attr_id]
                # Only include the set if it has at least one non-null value
                if any(!_is_null_in_db(v) for v in values)
                    formatted_values = _format_set(values, collection.set_parameters[attr_id].type)
                    push!(code_lines, "    $attr_id = $formatted_values,")
                end
            end
        end
    end

    return code_lines
end

"""
    _generate_time_series_parameters_code(db::DatabaseSQLite, collection::Collection, element_id::Int)

Generate code for time series data as DataFrames (excluding time series relations).
Time series relations are handled separately to avoid dependency issues.
"""
function _generate_time_series_parameters_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
)
    code_lines = String[]

    # Group time series by group_id (only parameters, not relations)
    time_series_groups = Dict{String, Vector{String}}()
    for (attr_id, attr) in collection.time_series
        group_id = attr.group_id
        if !haskey(time_series_groups, group_id)
            time_series_groups[group_id] = String[]
        end
        push!(time_series_groups[group_id], attr_id)
    end

    # Also collect time series relation group IDs to know which columns to exclude
    time_series_relation_columns = Set{String}()
    for (rel_attr_id, rel_attr) in collection.time_series_relations
        push!(time_series_relation_columns, rel_attr_id)
    end

    # Process all time series groups (including those with relations)
    all_groups = Set{String}()
    for (attr_id, attr) in collection.time_series
        push!(all_groups, attr.group_id)
    end
    for (attr_id, attr) in collection.time_series_relations
        push!(all_groups, attr.group_id)
    end

    for group_id in all_groups
        # Read time series data for this group
        df = _read_time_series_group_data(db, collection.id, group_id, element_id)

        if isempty(df)
            continue
        end

        # Exclude relation columns from the DataFrame
        df_filtered = select(df, Not(collect(intersect(names(df), time_series_relation_columns))))

        # Only include if there are non-dimension columns left (parameters)
        if ncol(df_filtered) <= length(_get_time_series_dimensions(collection, group_id))
            continue
        end

        # Generate DataFrame code
        df_code = _generate_dataframe_code(df_filtered, group_id)
        push!(code_lines, "    $group_id = $df_code,")
    end

    return code_lines
end

"""
    _get_time_series_dimensions(collection::Collection, group_id::String)

Get dimension names for a time series group.
"""
function _get_time_series_dimensions(collection::Collection, group_id::String)
    # Get dimensions from any time series or time series relation in this group
    for (attr_id, attr) in collection.time_series
        if attr.group_id == group_id
            return attr.dimension_names
        end
    end
    for (attr_id, attr) in collection.time_series_relations
        if attr.group_id == group_id
            return attr.dimension_names
        end
    end
    return String[]
end

"""
    _generate_scalar_relations_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code for setting scalar relations.
"""
function _generate_scalar_relations_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]

    for (attr_id, attr) in collection.scalar_relations
        # Read the related element's ID
        related_id = _read_scalar_value_by_id(db, collection.id, attr_id, element_id)

        if ismissing(related_id) || isnothing(related_id)
            continue
        end

        # Get the label of the related element
        related_label = _get_label_by_id(db, attr.relation_collection, related_id)

        # Skip empty relations
        if isempty(related_label)
            continue
        end

        push!(
            code_lines,
            "PSRDatabase.set_scalar_relation!(db, \"$(collection.id)\", \"$(attr.relation_collection)\", \"$label\", \"$related_label\", \"$(attr.relation_type)\")",
        )
    end

    return code_lines
end

"""
    _generate_vector_relations_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code for setting vector relations.
"""
function _generate_vector_relations_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]

    # Group vector relations by group_id
    groups_map = _map_of_groups_to_vector_attributes(db, collection.id)

    for (group_id, attr_ids) in groups_map
        # Only get relation attributes
        for attr_id in attr_ids
            if !haskey(collection.vector_relations, attr_id)
                continue
            end

            attr = collection.vector_relations[attr_id]

            # Read vector relation data
            related_ids = _read_vector_relation_data(
                db,
                collection.id,
                group_id,
                attr_id,
                element_id,
            )

            if isempty(related_ids)
                continue
            end

            # Convert IDs to labels
            related_labels = String[]
            for rid in related_ids
                if !ismissing(rid) && !isnothing(rid)
                    rlabel = _get_label_by_id(db, attr.relation_collection, rid)
                    push!(related_labels, rlabel)
                else
                    push!(related_labels, "")
                end
            end

            # Skip if all relations are empty
            if all(isempty, related_labels)
                continue
            end

            formatted_labels = "[" * join(["\"$l\"" for l in related_labels], ", ") * "]"
            push!(
                code_lines,
                "PSRDatabase.set_vector_relation!(db, \"$(collection.id)\", \"$(attr.relation_collection)\", \"$label\", $formatted_labels, \"$(attr.relation_type)\")",
            )
        end
    end

    return code_lines
end

"""
    _generate_set_relations_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code for setting set relations.
"""
function _generate_set_relations_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]

    # Group set relations by group_id
    groups_map = _map_of_groups_to_set_attributes(db, collection.id)

    for (group_id, attr_ids) in groups_map
        # Only get relation attributes
        for attr_id in attr_ids
            if !haskey(collection.set_relations, attr_id)
                continue
            end

            attr = collection.set_relations[attr_id]

            # Read set relation data
            related_ids = _read_set_relation_data(
                db,
                collection.id,
                group_id,
                attr_id,
                element_id,
            )

            if isempty(related_ids)
                continue
            end

            # Convert IDs to labels
            related_labels = String[]
            for rid in related_ids
                if !ismissing(rid) && !isnothing(rid)
                    rlabel = _get_label_by_id(db, attr.relation_collection, rid)
                    push!(related_labels, rlabel)
                else
                    push!(related_labels, "")
                end
            end

            # Skip if all relations are empty
            if all(isempty, related_labels)
                continue
            end

            formatted_labels = "[" * join(["\"$l\"" for l in related_labels], ", ") * "]"
            push!(
                code_lines,
                "PSRDatabase.set_relation!(db, \"$(collection.id)\", \"$(attr.relation_collection)\", \"$label\", $formatted_labels, \"$(attr.relation_type)\")",
            )
        end
    end

    return code_lines
end

"""
    _generate_time_series_relations_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code for adding time series relations row by row.
"""
function _generate_time_series_relations_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]

    # Group time series relations by group_id
    time_series_relation_groups = Dict{String, Vector{String}}()
    for (attr_id, attr) in collection.time_series_relations
        group_id = attr.group_id
        if !haskey(time_series_relation_groups, group_id)
            time_series_relation_groups[group_id] = String[]
        end
        push!(time_series_relation_groups[group_id], attr_id)
    end

    for (group_id, attr_ids) in time_series_relation_groups
        # Read time series data for this group
        df = _read_time_series_group_data(db, collection.id, group_id, element_id)

        if isempty(df)
            continue
        end

        # For each relation attribute, generate add_time_series_relation_row! calls
        for attr_id in attr_ids
            attr = collection.time_series_relations[attr_id]
            relation_collection = attr.relation_collection

            if !(attr_id in names(df))
                continue
            end

            # Generate code for each row
            for row_idx in 1:nrow(df)
                row = df[row_idx, :]
                id_val = row[attr_id]

                # Get related element label
                if ismissing(id_val) || isnothing(id_val)
                    related_label = ""
                else
                    related_label = _get_label_by_id(db, relation_collection, id_val)
                end

                # Skip empty relations
                if isempty(related_label)
                    continue
                end

                # Build dimensions from the row (only actual dimension columns)
                dimension_parts = String[]
                for dim_name in attr.dimension_names
                    if dim_name in names(df)
                        col_val = row[dim_name]
                        if dim_name == "date_time"
                            push!(dimension_parts, "date_time = DateTime(\"$col_val\")")
                        else
                            formatted_val = _format_value(col_val, typeof(col_val))
                            push!(dimension_parts, "$dim_name = $formatted_val")
                        end
                    end
                end

                dimensions_str = join(dimension_parts, ", ")

                push!(
                    code_lines,
                    "PSRDatabase.add_time_series_relation_row!(db, \"$(collection.id)\", \"$attr_id\", \"$label\", \"$related_label\"; $dimensions_str)",
                )
            end
        end
    end

    return code_lines
end

"""
    _generate_time_series_files_code(db::DatabaseSQLite, collection::Collection, element_id::Int, label::String)

Generate code for setting time series file paths.
"""
function _generate_time_series_files_code(
    db::DatabaseSQLite,
    collection::Collection,
    element_id::Int,
    label::String,
)
    code_lines = String[]

    for (attr_id, attr) in collection.time_series_files
        file_path = _read_time_series_file_path(db, collection.id, attr_id)

        if ismissing(file_path) || isnothing(file_path) || file_path == ""
            continue
        end

        push!(
            code_lines,
            "PSRDatabase.set_time_series_file!(db, \"$(collection.id)\", \"$attr_id\", \"$label\", \"$file_path\")",
        )
    end

    return code_lines
end

# Helper functions

"""
    _read_all_ids(db::DatabaseSQLite, collection_id::String)

Read all element IDs from a collection.
"""
function _read_all_ids(db::DatabaseSQLite, collection_id::String)
    query = "SELECT id FROM $collection_id ORDER BY id"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame
    return df[!, :id]
end

"""
    _read_all_labels(db::DatabaseSQLite, collection_id::String)

Read all element labels from a collection.
"""
function _read_all_labels(db::DatabaseSQLite, collection_id::String)
    collection = _get_collection(db, collection_id)

    # Check if collection has label attribute
    if !haskey(collection.scalar_parameters, "label")
        # Return empty strings for collections without labels (e.g., Configuration)
        num_elements = number_of_elements(db, collection_id)
        return fill("", num_elements)
    end

    query = "SELECT label FROM $collection_id ORDER BY id"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame
    return df[!, :label]
end

"""
    _read_scalar_value_by_id(db::DatabaseSQLite, collection_id::String, attribute_id::String, element_id::Int)

Read a scalar parameter value for a specific element ID.
"""
function _read_scalar_value_by_id(
    db::DatabaseSQLite,
    collection_id::String,
    attribute_id::String,
    element_id::Int,
)
    attribute = _get_attribute(db, collection_id, attribute_id)
    table = _table_where_is_located(attribute)

    query = "SELECT $attribute_id FROM $table WHERE id = $element_id"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return missing
    end

    result = df[1, 1]
    return _treat_query_result([result], attribute, nothing)[1]
end

"""
    _get_label_by_id(db::DatabaseSQLite, collection_id::String, element_id::Int)

Get the label of an element by its ID.
"""
function _get_label_by_id(
    db::DatabaseSQLite,
    collection_id::String,
    element_id::Int,
)
    collection = _get_collection(db, collection_id)

    if !haskey(collection.scalar_parameters, "label")
        return ""
    end

    query = "SELECT label FROM $collection_id WHERE id = $element_id"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return ""
    end

    return df[1, :label]
end

"""
    _read_vector_group_data(db::DatabaseSQLite, collection_id::String, group_id::String, element_id::Int)

Read all vector data for a specific group and element.
"""
function _read_vector_group_data(
    db::DatabaseSQLite,
    collection_id::String,
    group_id::String,
    element_id::Int,
)
    table_name = _vectors_group_table_name(collection_id, group_id)
    query = "SELECT * FROM $table_name WHERE id = $element_id ORDER BY vector_index"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return Dict{String, Vector}()
    end

    # Convert DataFrame to Dict of vectors
    result = Dict{String, Vector}()
    for col_name in names(df)
        if col_name != "id" && col_name != "vector_index"
            result[col_name] = df[!, col_name]
        end
    end

    return result
end

"""
    _read_vector_relation_data(db::DatabaseSQLite, collection_id::String, group_id::String, attribute_id::String, element_id::Int)

Read vector relation IDs for a specific attribute.
"""
function _read_vector_relation_data(
    db::DatabaseSQLite,
    collection_id::String,
    group_id::String,
    attribute_id::String,
    element_id::Int,
)
    table_name = _vectors_group_table_name(collection_id, group_id)
    query = "SELECT $attribute_id FROM $table_name WHERE id = $element_id ORDER BY vector_index"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return Int[]
    end

    return df[!, attribute_id]
end

"""
    _read_set_group_data(db::DatabaseSQLite, collection_id::String, group_id::String, element_id::Int)

Read all set data for a specific group and element.
"""
function _read_set_group_data(
    db::DatabaseSQLite,
    collection_id::String,
    group_id::String,
    element_id::Int,
)
    table_name = _set_group_table_name(collection_id, group_id)
    query = "SELECT * FROM $table_name WHERE id = $element_id"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return Dict{String, Set}()
    end

    # Convert DataFrame to Dict of sets
    result = Dict{String, Set}()
    for col_name in names(df)
        if col_name != "id"
            # Collect all non-missing values into a Set
            values = df[!, col_name]
            non_missing_values = filter(!ismissing, values)
            result[col_name] = Set(non_missing_values)
        end
    end

    return result
end

"""
    _read_set_relation_data(db::DatabaseSQLite, collection_id::String, group_id::String, attribute_id::String, element_id::Int)

Read set relation IDs for a specific attribute.
"""
function _read_set_relation_data(
    db::DatabaseSQLite,
    collection_id::String,
    group_id::String,
    attribute_id::String,
    element_id::Int,
)
    table_name = _set_group_table_name(collection_id, group_id)
    query = "SELECT $attribute_id FROM $table_name WHERE id = $element_id"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return Set{Int}()
    end

    values = df[!, attribute_id]
    non_missing_values = filter(!ismissing, values)
    return Set(non_missing_values)
end

"""
    _read_time_series_group_data(db::DatabaseSQLite, collection_id::String, group_id::String, element_id::Int)

Read all time series data for a specific group and element.
"""
function _read_time_series_group_data(
    db::DatabaseSQLite,
    collection_id::String,
    group_id::String,
    element_id::Int,
)
    table_name = _time_series_group_table_name(collection_id, group_id)
    query = "SELECT * FROM $table_name WHERE id = $element_id ORDER BY date_time"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return DataFrame()
    end

    # Remove the id column as it's not needed in the DataFrame
    select!(df, Not(:id))

    return df
end

"""
    _read_time_series_file_path(db::DatabaseSQLite, collection_id::String, attribute_id::String)

Read time series file path.
"""
function _read_time_series_file_path(
    db::DatabaseSQLite,
    collection_id::String,
    attribute_id::String,
)
    table_name = string(collection_id, "_time_series_files")

    # Check if table exists
    tables = SQLite.tables(db.sqlite_db)
    table_exists = any(t -> t.name == table_name, tables)

    if !table_exists
        return missing
    end

    query = "SELECT $attribute_id FROM $table_name"
    df = DBInterface.execute(db.sqlite_db, query) |> DataFrame

    if isempty(df)
        return missing
    end

    return df[1, 1]
end

"""
    _format_value(value, type::Type)

Format a value for code generation based on its type.
"""
function _format_value(value, type::Type)
    if ismissing(value) || isnothing(value)
        return "missing"
    elseif _is_null_in_db(value)
        return "missing"
    elseif type <: String
        # Escape special characters in strings
        escaped = replace(
            value,
            "\\" => "\\\\",
            "\"" => "\\\"",
            "\$" => "\\\$",
        )
        return "\"$escaped\""
    elseif type <: DateTime
        return "DateTime(\"$value\")"
    elseif type <: Float64
        return string(value)
    elseif type <: Int
        return string(value)
    else
        return string(value)
    end
end

"""
    _format_vector(values::Vector, type::Type)

Format a vector for code generation.
"""
function _format_vector(values::Vector, type::Type)
    # Filter out null values before formatting
    non_null_values = [v for v in values if !_is_null_in_db(v)]
    formatted_values = [_format_value(v, type) for v in non_null_values]
    return "[" * join(formatted_values, ", ") * "]"
end

"""
    _format_set(values::Set, type::Type)

Format a set for code generation.
"""
function _format_set(values::Set, type::Type)
    # Filter out null values before formatting
    non_null_values = [v for v in values if !_is_null_in_db(v)]
    formatted_values = [_format_value(v, type) for v in non_null_values]
    return "[" * join(formatted_values, ", ") * "]"
end

"""
    _generate_dataframe_code(df::DataFrame, df_name::String)

Generate code to create a DataFrame.
"""
function _generate_dataframe_code(df::DataFrame, df_name::String)
    if isempty(df)
        return "DataFrame()"
    end

    code_parts = String[]

    for col_name in names(df)
        col_values = df[!, col_name]

        # Determine the type from the first non-missing value
        col_type = eltype(col_values)
        if col_type == Any
            # Find first non-missing value to determine type
            for v in col_values
                if !_is_null_in_db(v)
                    col_type = typeof(v)
                    break
                end
            end
        end

        # Special handling for date_time column
        if col_name == "date_time"
            formatted_values = ["DateTime(\"$v\")" for v in col_values]
        else
            formatted_values = [_format_value(v, col_type) for v in col_values]
        end

        push!(code_parts, "$col_name = [" * join(formatted_values, ", ") * "]")
    end

    return "DataFrame(; " * join(code_parts, ", ") * ")"
end
