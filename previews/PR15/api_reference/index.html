<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · PSRDatabase</title><meta name="title" content="API Reference · PSRDatabase"/><meta property="og:title" content="API Reference · PSRDatabase"/><meta property="twitter:title" content="API Reference · PSRDatabase"/><meta name="description" content="Documentation for PSRDatabase."/><meta property="og:description" content="Documentation for PSRDatabase."/><meta property="twitter:description" content="Documentation for PSRDatabase."/><meta property="og:url" content="https://psrenergy.github.io/PSRDatabase.jl/api_reference/"/><meta property="twitter:url" content="https://psrenergy.github.io/PSRDatabase.jl/api_reference/"/><link rel="canonical" href="https://psrenergy.github.io/PSRDatabase.jl/api_reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PSRDatabase</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">PSRDatabase Overview</span><ul><li><a class="tocitem" href="../psrdatabase/introduction/">SQLite 101</a></li><li><a class="tocitem" href="../psrdatabase/rules/">PSRDatabase</a></li><li><a class="tocitem" href="../psrdatabase/time_series/">Time Series</a></li></ul></li><li><span class="tocitem">PSRDatabase Examples</span><ul><li><a class="tocitem" href="../sqlite_examples/migrations/">Migration Examples</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Database-Functions"><span>Database Functions</span></a></li><li><a class="tocitem" href="#Migration-Functions"><span>Migration Functions</span></a></li><li><a class="tocitem" href="#Data-Structures"><span>Data Structures</span></a></li><li><a class="tocitem" href="#Read-Functions"><span>Read Functions</span></a></li><li><a class="tocitem" href="#Create-Functions"><span>Create Functions</span></a></li><li><a class="tocitem" href="#Update-Functions"><span>Update Functions</span></a></li><li><a class="tocitem" href="#Delete-Functions"><span>Delete Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Validation-Functions"><span>Validation Functions</span></a></li><li><a class="tocitem" href="#Automatic-Docstring-Generation"><span>Automatic Docstring Generation</span></a></li><li><a class="tocitem" href="#Comparing-Databases"><span>Comparing Databases</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/psrenergy/PSRDatabase.jl/blob/master/docs/src/api_reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PSRDatabase-API"><a class="docs-heading-anchor" href="#PSRDatabase-API">PSRDatabase API</a><a id="PSRDatabase-API-1"></a><a class="docs-heading-anchor-permalink" href="#PSRDatabase-API" title="Permalink"></a></h1><h2 id="Database-Functions"><a class="docs-heading-anchor" href="#Database-Functions">Database Functions</a><a id="Database-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.close!-Tuple{PSRDatabase.DatabaseSQLite}"><a class="docstring-binding" href="#PSRDatabase.close!-Tuple{PSRDatabase.DatabaseSQLite}"><code>PSRDatabase.close!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">close!(db::DatabaseSQLite)</code></pre><p>Close the database connection.</p><p>This function closes the SQLite database connection and releases any associated resources. Always call this function when you&#39;re done working with a database to ensure proper cleanup.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection to close</li></ul><p><strong>Returns</strong></p><ul><li>Nothing</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Open a database
db = PSRDatabase.load_db(&quot;my_database.sqlite&quot;)

# Work with the database
# ... perform operations ...

# Close the database when done
PSRDatabase.close!(db)</code></pre><p><strong>Notes</strong></p><p>After closing, the database connection cannot be used for further operations. You&#39;ll need to call <code>load_db</code> again if you want to work with the database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/database_sqlite.jl#L524-L557">source</a></section></details></article><h2 id="Migration-Functions"><a class="docs-heading-anchor" href="#Migration-Functions">Migration Functions</a><a id="Migration-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Migration-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.create_migration-Tuple{String, Integer}"><a class="docstring-binding" href="#PSRDatabase.create_migration-Tuple{String, Integer}"><code>PSRDatabase.create_migration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_migration(path_migrations_directory::String, version::Integer)</code></pre><p>Creates a new migration in the migrations folder with the current date, the correct version and the name given in this function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/migrations.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.generate_current_schema_file-Tuple{SQLite.DB, String}"><a class="docstring-binding" href="#PSRDatabase.generate_current_schema_file-Tuple{SQLite.DB, String}"><code>PSRDatabase.generate_current_schema_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_current_schema_file(db::SQLite.DB, file::String)</code></pre><p>Generates a .sql file based in sqlite_master that indicates the statements to create a new db from scratch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/migrations.jl#L210-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.test_migrations-Tuple{String}"><a class="docstring-binding" href="#PSRDatabase.test_migrations-Tuple{String}"><code>PSRDatabase.test_migrations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_migrations(path_migrations_directory::String)</code></pre><p>Function to put in the test suite of the module to verify that the migrations are behaving correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/migrations.jl#L229-L233">source</a></section></details></article><h2 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.Collection"><a class="docstring-binding" href="#PSRDatabase.Collection"><code>PSRDatabase.Collection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Collection</code></pre><p>This struct stores the definition of a collection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/collection.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.Attribute"><a class="docstring-binding" href="#PSRDatabase.Attribute"><code>PSRDatabase.Attribute</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Attribute</code></pre><p>Abstract type for attributes, the building blocks of collections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/attribute.jl#L1-L5">source</a></section></details></article><h2 id="Read-Functions"><a class="docs-heading-anchor" href="#Read-Functions">Read Functions</a><a id="Read-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.READ_METHODS_BY_CLASS_OF_ATTRIBUTE"><a class="docstring-binding" href="#PSRDatabase.READ_METHODS_BY_CLASS_OF_ATTRIBUTE"><code>PSRDatabase.READ_METHODS_BY_CLASS_OF_ATTRIBUTE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const READ_METHODS_BY_CLASS_OF_ATTRIBUTE</code></pre><p>A dictionary mapping attribute classes to their corresponding read method names in PSRDatabase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._PSRDatabase_null_value-Tuple{Type{Float64}}"><a class="docstring-binding" href="#PSRDatabase._PSRDatabase_null_value-Tuple{Type{Float64}}"><code>PSRDatabase._PSRDatabase_null_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_PSRDatabase_null_value(::Type{Float64})
_PSRDatabase_null_value(::Type{Int64})
_PSRDatabase_null_value(::Type{String})
_PSRDatabase_null_value(::Type{DateTime})</code></pre><p>Get the null/missing value representation for a specific type in PSRDatabase.</p><p><strong>Arguments</strong></p><ul><li>Type parameter: The data type to get the null value for</li></ul><p><strong>Returns</strong></p><ul><li>For <code>Float64</code>: <code>NaN</code></li><li>For <code>Int64</code>: <code>typemin(Int64)</code></li><li>For <code>String</code>: <code>&quot;&quot;</code></li><li>For <code>DateTime</code>: <code>typemin(DateTime)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1281-L1299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._get_id-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase._get_id-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase._get_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_id(db::DatabaseSQLite, collection_id::String, label::String)::Integer</code></pre><p>Internal function to retrieve the numeric ID for an element in a collection based on its label.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>label::String</code>: The label of the element to find</li></ul><p><strong>Returns</strong></p><ul><li><code>Integer</code>: The numeric ID of the element</li></ul><p><strong>Throws</strong></p><ul><li>Error if the label does not exist in the collection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L37-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._get_scalar_relation_map-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase._get_scalar_relation_map-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase._get_scalar_relation_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_scalar_relation_map(db::DatabaseSQLite, collection_from::String, collection_to::String, relation_type::String)</code></pre><p>Internal function to retrieve the scalar relation mapping as a vector of indices.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>relation_type::String</code>: The type of relation</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: A vector of indices mapping each element in <code>collection_from</code> to elements in <code>collection_to</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L563-L578">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._get_set_relation_map-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase._get_set_relation_map-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase._get_set_relation_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_set_relation_map(db::DatabaseSQLite, collection_from::String, collection_to::String, relation_type::String)</code></pre><p>Internal function to retrieve the set relation mapping as a vector of index vectors.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>relation_type::String</code>: The type of relation</li></ul><p><strong>Returns</strong></p><pre><code class="language-julia hljs">- `Vector{Vector{Int}}`: A vector of vectors of indices mapping each element in `collection_from` to elements in `collection_to`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L886-L901">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._get_vector_relation_map-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase._get_vector_relation_map-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase._get_vector_relation_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_vector_relation_map(db::DatabaseSQLite, collection_from::String, collection_to::String, relation_type::String)</code></pre><p>Internal function to retrieve the vector relation mapping as a vector of index vectors.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>relation_type::String</code>: The type of relation</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Int}}</code>: A vector of vectors of indices mapping each element in <code>collection_from</code> to elements in <code>collection_to</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L719-L734">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._is_null_in_db-Tuple{Float64}"><a class="docstring-binding" href="#PSRDatabase._is_null_in_db-Tuple{Float64}"><code>PSRDatabase._is_null_in_db</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_is_null_in_db(value::Float64)
_is_null_in_db(value::Int64)
_is_null_in_db(value::String)
_is_null_in_db(value::DateTime)</code></pre><p>Check if a value represents a null/missing value in PSRDatabase.</p><p><strong>Arguments</strong></p><ul><li><code>value</code>: The value to check</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the value is null, <code>false</code> otherwise</li></ul><p><strong>Details</strong></p><ul><li>For <code>Float64</code>: checks if <code>isnan(value)</code></li><li>For <code>Int64</code>: checks if <code>value == typemin(Int64)</code></li><li>For <code>String</code>: checks if <code>isempty(value)</code></li><li>For <code>DateTime</code>: checks if <code>value == typemin(DateTime)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1305-L1327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._query_set-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.SetParameter, Integer}"><a class="docstring-binding" href="#PSRDatabase._query_set-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.SetParameter, Integer}"><code>PSRDatabase._query_set</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_query_set(db::DatabaseSQLite, attribute::SetParameter, id::Integer; default::Union{Nothing, Any} = nothing)</code></pre><p>Internal function to query set parameter values for a specific element.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>attribute::SetParameter</code>: The set parameter attribute</li><li><code>id::Integer</code>: The numeric ID of the element</li><li><code>default::Union{Nothing, Any}</code>: Optional default value for missing data</li></ul><p><strong>Returns</strong></p><pre><code class="language-julia hljs">- `Vector`: The vector of set parameter values, ordered by rowid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L439-L453">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._query_vector-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.VectorParameter, Integer}"><a class="docstring-binding" href="#PSRDatabase._query_vector-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.VectorParameter, Integer}"><code>PSRDatabase._query_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_query_vector(db::DatabaseSQLite, attribute::VectorParameter, id::Integer; default::Union{Nothing, Any} = nothing)</code></pre><p>Internal function to query vector parameter values for a specific element.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>attribute::VectorParameter</code>: The vector parameter attribute</li><li><code>id::Integer</code>: The numeric ID of the element</li><li><code>default::Union{Nothing, Any}</code>: Optional default value for missing data</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: The vector of parameter values, ordered by vector_index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L336-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._read_time_series_table-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.Attribute, Integer}"><a class="docstring-binding" href="#PSRDatabase._read_time_series_table-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.Attribute, Integer}"><code>PSRDatabase._read_time_series_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_read_time_series_table(db::DatabaseSQLite, attribute::Attribute, id::Integer)</code></pre><p>Internal function to read the complete time series table for a specific element.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>attribute::Attribute</code>: The time series attribute</li><li><code>id::Integer</code>: The numeric ID of the element</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing all time series data for the element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1073-L1087">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._treat_query_result-Tuple{Vector{&lt;:Union{Missing, String}}, PSRDatabase.Attribute, Any}"><a class="docstring-binding" href="#PSRDatabase._treat_query_result-Tuple{Vector{&lt;:Union{Missing, String}}, PSRDatabase.Attribute, Any}"><code>PSRDatabase._treat_query_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_treat_query_result(query_results::Vector{&lt;:Union{Missing, String}}, attribute::Attribute, default::Union{Nothing, Any})</code></pre><p>Internal function to process string query results, replacing missing values with appropriate defaults. Handles both String and DateTime types (DateTime values are stored as strings in the database).</p><p><strong>Arguments</strong></p><ul><li><code>query_results::Vector{&lt;:Union{Missing, String}}</code>: The query results that may contain missing values</li><li><code>attribute::Attribute</code>: The attribute being queried</li><li><code>default::Union{Nothing, Any}</code>: The default value to use for missing data</li></ul><p><strong>Returns</strong></p><ul><li>A vector with missing values replaced by the specified default, with DateTime conversion if applicable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1213-L1228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._treat_query_result-Tuple{Vector{Missing}, PSRDatabase.Attribute, Any}"><a class="docstring-binding" href="#PSRDatabase._treat_query_result-Tuple{Vector{Missing}, PSRDatabase.Attribute, Any}"><code>PSRDatabase._treat_query_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_treat_query_result(query_results::Vector{Missing}, attribute::Attribute, default::Union{Nothing, Any})</code></pre><p>Internal function to process query results that are all missing values, replacing them with appropriate defaults.</p><p><strong>Arguments</strong></p><ul><li><code>query_results::Vector{Missing}</code>: The query results containing only missing values</li><li><code>attribute::Attribute</code>: The attribute being queried</li><li><code>default::Union{Nothing, Any}</code>: The default value to use for missing data</li></ul><p><strong>Returns</strong></p><ul><li>A vector filled with the appropriate default values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1142-L1156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._treat_query_result-Union{Tuple{T}, Tuple{Array{Union{Missing, T}, 1}, PSRDatabase.Attribute, Any}} where T&lt;:Union{Float64, Int64}"><a class="docstring-binding" href="#PSRDatabase._treat_query_result-Union{Tuple{T}, Tuple{Array{Union{Missing, T}, 1}, PSRDatabase.Attribute, Any}} where T&lt;:Union{Float64, Int64}"><code>PSRDatabase._treat_query_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_treat_query_result(query_results::Vector{Union{Missing, T}}, attribute::Attribute, default::Union{Nothing, Any}) where {T &lt;: Union{Int64, Float64}}</code></pre><p>Internal function to process numeric query results, replacing missing values with appropriate defaults.</p><p><strong>Arguments</strong></p><ul><li><code>query_results::Vector{Union{Missing, T}}</code>: The query results that may contain missing values</li><li><code>attribute::Attribute</code>: The attribute being queried</li><li><code>default::Union{Nothing, Any}</code>: The default value to use for missing data</li></ul><p><strong>Returns</strong></p><ul><li>A vector with missing values replaced by the specified default</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1172-L1186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase._treat_query_result-Union{Tuple{T}, Tuple{Vector{T}, PSRDatabase.Attribute, Any}} where T&lt;:Union{Float64, Int64}"><a class="docstring-binding" href="#PSRDatabase._treat_query_result-Union{Tuple{T}, Tuple{Vector{T}, PSRDatabase.Attribute, Any}} where T&lt;:Union{Float64, Int64}"><code>PSRDatabase._treat_query_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_treat_query_result(results::Vector{T}, ::Attribute, ::Union{Nothing, Any}) where {T &lt;: Union{Int64, Float64}}</code></pre><p>Internal function to process numeric query results that contain no missing values. Returns the results unchanged.</p><p><strong>Arguments</strong></p><ul><li><code>results::Vector{T}</code>: The query results with no missing values</li><li><code>::Attribute</code>: The attribute being queried (unused)</li><li><code>::Union{Nothing, Any}</code>: The default value (unused)</li></ul><p><strong>Returns</strong></p><ul><li>The original results vector unchanged</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1259-L1274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.number_of_elements-Tuple{PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.number_of_elements-Tuple{PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.number_of_elements</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">number_of_elements(db::DatabaseSQLite, collection_id::String)::Int</code></pre><p>Return the total number of elements in the specified collection.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection to count elements from</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The number of elements in the collection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L15-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_scalar_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, Integer}"><a class="docstring-binding" href="#PSRDatabase.read_scalar_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, Integer}"><code>PSRDatabase.read_scalar_parameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_scalar_parameter(db::DatabaseSQLite, collection_id::String, attribute_id::String, id::Integer; default::Union{Nothing, Any} = nothing)</code></pre><p>Read the value of a scalar parameter attribute for a specific element identified by numeric ID.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the scalar parameter attribute to read</li><li><code>id::Integer</code>: The numeric ID of the element to read from</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values</li></ul><p><strong>Returns</strong></p><ul><li>The scalar parameter value for the specified element. Type matches the attribute type (Float64, Int64, String, or DateTime)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">capacity = PSRDatabase.read_scalar_parameter(db, &quot;Plant&quot;, &quot;capacity&quot;, 1)  # 2.02</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L177-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_scalar_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_scalar_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_scalar_parameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_scalar_parameter(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String; default::Union{Nothing, Any} = nothing)</code></pre><p>Read the value of a scalar parameter attribute for a specific element identified by label.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the scalar parameter attribute to read</li><li><code>label::String</code>: The label of the element to read from</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values</li></ul><p><strong>Returns</strong></p><ul><li>The scalar parameter value for the specified element. Type matches the attribute type (Float64, Int64, String, or DateTime)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a string label
name = PSRDatabase.read_scalar_parameter(db, &quot;Resource&quot;, &quot;label&quot;, &quot;Resource 1&quot;)  # &quot;Resource 1&quot;

# Read a numeric value
capacity = PSRDatabase.read_scalar_parameter(db, &quot;Plant&quot;, &quot;capacity&quot;, &quot;Plant 3&quot;)  # 54.0</code></pre><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the label does not exist in the collection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L127-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_scalar_parameters-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_scalar_parameters-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase.read_scalar_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_scalar_parameters(db::DatabaseSQLite, collection_id::String, attribute_id::String; default::Union{Nothing, Any} = nothing)</code></pre><p>Read all values of a scalar parameter attribute for all elements in a collection.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the scalar parameter attribute to read</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values (NaN for Float64, typemin(Int64) for Int64, &quot;&quot; for String, typemin(DateTime) for DateTime)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: A vector containing the scalar parameter values for all elements, ordered by ID. The element type matches the attribute type (Float64, Int64, String, or DateTime)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read labels (returns Vector{String})
labels = PSRDatabase.read_scalar_parameters(db, &quot;Plant&quot;, &quot;label&quot;)  # [&quot;Plant 1&quot;, &quot;Plant 2&quot;, &quot;Plant 3&quot;]

# Read numeric values (returns Vector{Float64})
capacities = PSRDatabase.read_scalar_parameters(db, &quot;Plant&quot;, &quot;capacity&quot;)  # [2.02, 53.0, 54.0]

# Read dates (returns Vector{DateTime})
dates = PSRDatabase.read_scalar_parameters(db, &quot;Configuration&quot;, &quot;date_initial&quot;)  # [DateTime(2020, 1, 1)]

# With default value for missing data
values = PSRDatabase.read_scalar_parameters(db, &quot;Cost&quot;, &quot;value_without_default&quot;; default = 2.0)  # [2.0, 2.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L72-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_scalar_relation-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 4}}"><a class="docstring-binding" href="#PSRDatabase.read_scalar_relation-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 4}}"><code>PSRDatabase.read_scalar_relation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_scalar_relation(db::DatabaseSQLite, collection_from::String, collection_to::String, relation_type::String, collection_from_label::String)</code></pre><p>Read the scalar relation mapping for a specific element from one collection to another.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>relation_type::String</code>: The type of relation (e.g., &quot;id&quot;, &quot;group&quot;, &quot;turbine_to&quot;)</li><li><code>collection_from_label::String</code>: The label of the element in the source collection</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The label from <code>collection_to</code> that the specified element relates to. Empty string (<code>&quot;&quot;</code>) indicates a null relation (no connection).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get which resource &quot;Plant 1&quot; is connected to
resource = PSRDatabase.read_scalar_relation(db, &quot;Plant&quot;, &quot;Resource&quot;, &quot;id&quot;, &quot;Plant 1&quot;)  # &quot;Resource 1&quot;

# Get which plant &quot;Plant 3&quot; connects to via turbine
turbine = PSRDatabase.read_scalar_relation(db, &quot;Plant&quot;, &quot;Plant&quot;, &quot;turbine_to&quot;, &quot;Plant 3&quot;)  # &quot;Plant 2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L518-L544">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_scalar_relations-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_scalar_relations-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_scalar_relations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_scalar_relations(db::DatabaseSQLite, collection_from::String, collection_to::String, relation_type::String)</code></pre><p>Read all scalar relation mappings from one collection to another.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>relation_type::String</code>: The type of relation (e.g., &quot;id&quot;, &quot;group&quot;, &quot;turbine_to&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: A vector of labels from <code>collection_to</code> representing the relation for each element in <code>collection_from</code>, ordered by ID. Empty strings (<code>&quot;&quot;</code>) indicate null relations (no connection).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get which resource each plant is connected to
resources = PSRDatabase.read_scalar_relations(db, &quot;Plant&quot;, &quot;Resource&quot;, &quot;id&quot;)
# [&quot;Resource 1&quot;, &quot;&quot;, &quot;&quot;]  # Plant 1 → Resource 1, Plant 2 and 3 → no resource

# Get turbine connections between plants
turbines = PSRDatabase.read_scalar_relations(db, &quot;Plant&quot;, &quot;Plant&quot;, &quot;turbine_to&quot;)
# [&quot;&quot;, &quot;&quot;, &quot;Plant 2&quot;]  # Only Plant 3 connects to Plant 2</code></pre><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the relation is not a scalar relation (e.g., trying to read a vector relation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L467-L498">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_set_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_set_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_set_parameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_set_parameter(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String; default::Union{Nothing, Any} = nothing)</code></pre><p>Read the values of a set parameter attribute for a specific element identified by label.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the set parameter attribute to read</li><li><code>label::String</code>: The label of the element to read from</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values</li></ul><p><strong>Returns</strong></p><pre><code class="language-julia hljs">- `Vector`: A vector containing the parameter values for the specified element. Type matches the attribute type (Float64, Int64, String, or DateTime). Returns an empty vector if no data exists.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L404-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_set_parameters-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_set_parameters-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase.read_set_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_set_parameters(db::DatabaseSQLite, collection_id::String, attribute_id::String; default::Union{Nothing, Any} = nothing)</code></pre><p>Read all values of a set parameter attribute for all elements in a collection.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the set parameter attribute to read</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values</li></ul><p><strong>Returns</strong></p><pre><code class="language-julia hljs">- `Vector{Vector}`: A vector of vectors, where each inner vector contains the parameter values for one element. Inner vector type matches the attribute type (Float64, Int64, String, or DateTime). Empty vectors are returned for elements with no data.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L365-L380">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_set_relation-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 4}}"><a class="docstring-binding" href="#PSRDatabase.read_set_relation-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 4}}"><code>PSRDatabase.read_set_relation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_set_relation(db::DatabaseSQLite, collection_from::String, collection_to::String, collection_from_label::String, relation_type::String)</code></pre><p>Read the set relation mapping for a specific element from one collection to another.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>collection_from_label::String</code>: The label of the element in the source collection</li><li><code>relation_type::String</code>: The type of relation </li></ul><p><strong>Returns</strong></p><pre><code class="language-julia hljs">- `Vector{String}`: A vector of labels from `collection_to` that the specified element relates to. Returns an empty vector if no relations exist. Empty strings within the vector indicate null relations.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get which costs &quot;Plant 1&quot; is associated with
costs = PSRDatabase.read_set_relation(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 1&quot;, &quot;id&quot;)  # [&quot;Cost 2&quot;]
# Get multiple related elements
costs = PSRDatabase.read_set_relation(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 2&quot;, &quot;id&quot;)  # [&quot;Cost 1&quot;, &quot;Cost 2&quot;]
# Element with no relations
costs = PSRDatabase.read_set_relation(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 3&quot;, &quot;id&quot;)  # String[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L840-L867">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_set_relations-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_set_relations-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_set_relations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_set_relation(db::DatabaseSQLite, collection_from::String, collection_to::String, collection_from_label::String, relation_type::String)</code></pre><p>Read the set relation mapping for a specific element from one collection to another.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>collection_from_label::String</code>: The label of the element in the source collection</li><li><code>relation_type::String</code>: The type of relation </li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: A vector of labels from <code>collection_to</code> that the specified element relates to. Returns an empty vector if no relations exist. Empty strings within the vector indicate null relations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get which costs &quot;Plant 1&quot; is associated with
costs = PSRDatabase.read_set_relations(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 1&quot;, &quot;id&quot;)  # [&quot;Cost 2&quot;]

# Get multiple related elements
costs = PSRDatabase.read_set_relations(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 2&quot;, &quot;id&quot;)  # [&quot;Cost 1&quot;, &quot;Cost 2&quot;]

# Element with no relations
costs = PSRDatabase.read_set_relations(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 3&quot;, &quot;id&quot;)  # String[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L783-L812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_time_series_file-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_time_series_file-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase.read_time_series_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_time_series_file(db::DatabaseSQLite, collection_id::String, attribute_id::String)::String</code></pre><p>Read the file path stored in a time series file attribute.</p><p>Time series file attributes store references to external files containing time series data. This function retrieves the file path string.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the time series file attribute</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The file path stored in the attribute, or an empty string (<code>&quot;&quot;</code>) if not set</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read time series file paths
wind_file = PSRDatabase.read_time_series_file(db, &quot;Plant&quot;, &quot;wind_speed&quot;)  # &quot;some_file.txt&quot;
direction_file = PSRDatabase.read_time_series_file(db, &quot;Plant&quot;, &quot;wind_direction&quot;)  # &quot;some_file2&quot;

# After updating
PSRDatabase.set_time_series_file!(db, &quot;Plant&quot;; wind_speed = &quot;some_file3.txt&quot;)
wind_file = PSRDatabase.read_time_series_file(db, &quot;Plant&quot;, &quot;wind_speed&quot;)  # &quot;some_file3.txt&quot;</code></pre><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the attribute is not a time series file attribute</li><li><code>DatabaseException</code> if the table has more than one row (should only have one row for time series file attributes)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L950-L984">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_time_series_row-Tuple{Any, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_time_series_row-Tuple{Any, String, String}"><code>PSRDatabase.read_time_series_row</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_time_series_row(db::DatabaseSQLite, collection_id::String, attribute_id::String; date_time::DateTime)</code></pre><p>Read a row of time series data for all elements in a collection at a specific date/time.</p><p>This function is optimized for read-only databases and uses caching for efficient access to time series data.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection (must be read-only)</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the time series attribute</li><li><code>date_time::DateTime</code>: The date/time to query data for</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: A vector containing the time series values for all elements at the specified date/time</li></ul><p><strong>Note</strong></p><p>This function only works with read-only databases and will throw an error if called on a writable database.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">generation = PSRDatabase.read_time_series_row(db, &quot;Thermal&quot;, &quot;generation&quot;; date_time = DateTime(2025, 1, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1015-L1042">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_time_series_table-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_time_series_table-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_time_series_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_time_series_table(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String)</code></pre><p>Read the complete time series table for a specific element identified by label.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the time series attribute</li><li><code>label::String</code>: The label of the element to read data for</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame containing all time series data (dimensions and values) for the specified element</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">generation_table = PSRDatabase.read_time_series_table(db, &quot;Thermal&quot;, &quot;generation&quot;, &quot;Plant1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L1098-L1119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_vector_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_vector_parameter-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_vector_parameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_vector_parameter(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String; default::Union{Nothing, Any} = nothing)</code></pre><p>Read the values of a vector parameter attribute for a specific element identified by label.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the vector parameter attribute to read</li><li><code>label::String</code>: The label of the element to read from</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: A vector containing the parameter values for the specified element. Type matches the attribute type (Float64, Int64, String, or DateTime). Returns an empty vector if no data exists.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read vector with data
factors = PSRDatabase.read_vector_parameter(db, &quot;Plant&quot;, &quot;some_factor&quot;, &quot;Plant 1&quot;)  # [1.0]
factors = PSRDatabase.read_vector_parameter(db, &quot;Plant&quot;, &quot;some_factor&quot;, &quot;Plant 2&quot;)  # [1.0, 2.0]

# Read empty vector
factors = PSRDatabase.read_vector_parameter(db, &quot;Plant&quot;, &quot;some_factor&quot;, &quot;Plant 3&quot;)  # Float64[]

# Read date vectors
dates = PSRDatabase.read_vector_parameter(db, &quot;Plant&quot;, &quot;date_some_date&quot;, &quot;Plant 2&quot;)
# [DateTime(2020, 1, 1), DateTime(2020, 1, 2)]

# Elements with null dates return typemin(DateTime)
dates = PSRDatabase.read_vector_parameter(db, &quot;Plant&quot;, &quot;date_some_date&quot;, &quot;Plant 4&quot;)
# [typemin(DateTime), typemin(DateTime)]</code></pre><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the label does not exist in the collection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L278-L317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_vector_parameters-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_vector_parameters-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase.read_vector_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_vector_parameters(db::DatabaseSQLite, collection_id::String, attribute_id::String; default::Union{Nothing, Any} = nothing)</code></pre><p>Read all values of a vector parameter attribute for all elements in a collection.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection</li><li><code>attribute_id::String</code>: The identifier of the vector parameter attribute to read</li><li><code>default::Union{Nothing, Any}</code>: Optional default value to use for missing data. If <code>nothing</code>, uses type-specific null values</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector}</code>: A vector of vectors, where each inner vector contains the parameter values for one element. Inner vector type matches the attribute type (Float64, Int64, String, or DateTime). Empty vectors are returned for elements with no data.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read numeric vector parameters
values = PSRDatabase.read_vector_parameters(db, &quot;Resource&quot;, &quot;some_value&quot;)
# [[1, 2, 3.0], [1, 2, 4.0]]

# Read vector parameters with some empty elements
factors = PSRDatabase.read_vector_parameters(db, &quot;Plant&quot;, &quot;some_factor&quot;)
# [[1.0], [1.0, 2.0], Float64[], [1.0, 2.0]]

# Read date vectors
dates = PSRDatabase.read_vector_parameters(db, &quot;Plant&quot;, &quot;date_some_date&quot;)
# [[DateTime(2020, 1, 1)], [DateTime(2020, 1, 1), DateTime(2020, 1, 2)], DateTime[], ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L223-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_vector_relation-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 4}}"><a class="docstring-binding" href="#PSRDatabase.read_vector_relation-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 4}}"><code>PSRDatabase.read_vector_relation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_vector_relation(db::DatabaseSQLite, collection_from::String, collection_to::String, collection_from_label::String, relation_type::String)</code></pre><p>Read the vector relation mapping for a specific element from one collection to another.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>collection_from_label::String</code>: The label of the element in the source collection</li><li><code>relation_type::String</code>: The type of relation </li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: A vector of labels from <code>collection_to</code> that the specified element relates to. Returns an empty vector if no relations exist. Empty strings within the vector indicate null relations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get which costs &quot;Plant 1&quot; is associated with
costs = PSRDatabase.read_vector_relation(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 1&quot;, &quot;id&quot;)  # [&quot;Cost 2&quot;]

# Get multiple related elements
costs = PSRDatabase.read_vector_relation(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 2&quot;, &quot;id&quot;)  # [&quot;Cost 1&quot;, &quot;Cost 2&quot;]

# Element with no relations
costs = PSRDatabase.read_vector_relation(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 3&quot;, &quot;id&quot;)  # String[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L671-L700">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.read_vector_relations-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.read_vector_relations-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.read_vector_relations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_vector_relations(db::DatabaseSQLite, collection_from::String, collection_to::String, relation_type::String)</code></pre><p>Read all vector relation mappings from one collection to another.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the source collection</li><li><code>collection_to::String</code>: The identifier of the target collection</li><li><code>relation_type::String</code>: The type of relation </li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{String}}</code>: A vector of vectors, where each inner vector contains labels from <code>collection_to</code> representing the relations for one element in <code>collection_from</code>, ordered by ID. Empty vectors indicate no relations. Empty strings within vectors indicate null relations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get which costs each plant is associated with
costs = PSRDatabase.read_vector_relations(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;id&quot;)
# [[&quot;Cost 1&quot;], [&quot;Cost 1&quot;, &quot;Cost 2&quot;], String[]]
# Plant 1 → Cost 1, Plant 2 → Cost 1 and Cost 2, Plant 3 → no costs

# After updating Plant 1&#39;s costs
PSRDatabase.set_vector_relation!(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant 1&quot;, [&quot;Cost 2&quot;], &quot;id&quot;)
costs = PSRDatabase.read_vector_relations(db, &quot;Plant&quot;, &quot;Cost&quot;, &quot;id&quot;)
# [[&quot;Cost 2&quot;], [&quot;Cost 1&quot;, &quot;Cost 2&quot;], String[]]</code></pre><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the relation is not a vector relation (e.g., trying to read a scalar relation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/read.jl#L610-L643">source</a></section></details></article><h2 id="Create-Functions"><a class="docs-heading-anchor" href="#Create-Functions">Create Functions</a><a id="Create-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Create-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.add_time_series_row!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Any}"><a class="docstring-binding" href="#PSRDatabase.add_time_series_row!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Any}"><code>PSRDatabase.add_time_series_row!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_time_series_row!(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String, val; dimensions...)</code></pre><p>Add or update a value in a time series attribute for a specific element and dimension combination.</p><p>This function performs an &quot;upsert&quot; operation - if a row with the specified dimensions already exists, it updates the value; otherwise, it inserts a new row.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>attribute_id::String</code>: The identifier of the time series attribute</li><li><code>label::String</code>: The label of the element to add/update the time series value for</li><li><code>val</code>: The value to set for the time series at the specified dimensions</li><li><code>dimensions...</code>: Named arguments specifying the dimension values (e.g., <code>date_time = DateTime(2020, 1, 1)</code>, <code>stage = 1</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the attribute is not a time series</li><li><code>DatabaseException</code> if the number of dimensions doesn&#39;t match the attribute definition</li><li><code>DatabaseException</code> if dimension names don&#39;t match the attribute definition</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Add time series value with date_time dimension
PSRDatabase.add_time_series_row!(
    db,
    &quot;Plant&quot;,
    &quot;generation&quot;,
    &quot;Plant 1&quot;,
    100.5;
    date_time = DateTime(2020, 1, 1),
)

# Add time series value with multiple dimensions
PSRDatabase.add_time_series_row!(
    db,
    &quot;Plant&quot;,
    &quot;cost&quot;,
    &quot;Plant 1&quot;,
    50.0;
    date_time = DateTime(2020, 1, 1),
    stage = 1,
)

# Update existing time series value (same dimensions)
PSRDatabase.add_time_series_row!(
    db,
    &quot;Plant&quot;,
    &quot;generation&quot;,
    &quot;Plant 1&quot;,
    120.0;
    date_time = DateTime(2020, 1, 1),  # This will update the existing value
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/create.jl#L519-L580">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.create_element!-Tuple{PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.create_element!-Tuple{PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.create_element!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_element!(db::DatabaseSQLite, collection_id::String; kwargs...)</code></pre><p>Create a new element in the specified collection with the given attributes.</p><p><strong>Arguments</strong></p><ul><li><p><code>db::DatabaseSQLite</code>: The database connection</p></li><li><p><code>collection_id::String</code>: The identifier of the collection to add the element to</p></li><li><p><code>kwargs...</code>: Named arguments specifying the attribute values for the new element</p><ul><li>Scalar parameters: Single values (Int, Float64, String, DateTime)</li><li>Vector parameters: Arrays of values that must all have the same length within a group</li><li>Scalar relations: String labels of related elements or integer IDs</li><li>Vector relations: Arrays of string labels of related elements</li><li>Time series: File paths as strings</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the collection doesn&#39;t exist</li><li><code>DatabaseException</code> if an attribute doesn&#39;t exist or has invalid type</li><li><code>DatabaseException</code> if vector parameters in the same group have different lengths</li><li><code>DatabaseException</code> if a required attribute is missing (e.g., label)</li><li><code>SQLiteException</code> if a label already exists (violates unique constraint)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create element with scalar parameters
PSRDatabase.create_element!(db, &quot;Configuration&quot;; label = &quot;Toy Case&quot;, value1 = 1.0)

# Create element with vector parameters
PSRDatabase.create_element!(
    db,
    &quot;Resource&quot;;
    label = &quot;Resource 1&quot;,
    type = &quot;E&quot;,
    some_value = [1.0, 2.0, 3.0],
)

# Create element with scalar relation (using label)
PSRDatabase.create_element!(db, &quot;Plant&quot;; label = &quot;Plant 1&quot;, capacity = 50.0, resource_id = &quot;Resource 1&quot;)

# Create element with vector relations
PSRDatabase.create_element!(
    db,
    &quot;Process&quot;;
    label = &quot;Sugar Mill&quot;,
    product_input = [&quot;Sugarcane&quot;],
    factor_input = [1.0],
    product_output = [&quot;Sugar&quot;, &quot;Molasse&quot;, &quot;Bagasse&quot;],
    factor_output = [0.3, 0.3, 0.4],
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/create.jl#L283-L342">source</a></section></details></article><h2 id="Update-Functions"><a class="docs-heading-anchor" href="#Update-Functions">Update Functions</a><a id="Update-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.UPDATE_METHODS_BY_CLASS_OF_ATTRIBUTE"><a class="docstring-binding" href="#PSRDatabase.UPDATE_METHODS_BY_CLASS_OF_ATTRIBUTE"><code>PSRDatabase.UPDATE_METHODS_BY_CLASS_OF_ATTRIBUTE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const UPDATE_METHODS_BY_CLASS_OF_ATTRIBUTE</code></pre><p>A dictionary mapping attribute classes to their corresponding update method names in PSRDatabase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.set_scalar_relation!-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 5}}"><a class="docstring-binding" href="#PSRDatabase.set_scalar_relation!-Tuple{PSRDatabase.DatabaseSQLite, Vararg{String, 5}}"><code>PSRDatabase.set_scalar_relation!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_scalar_relation!(db::DatabaseSQLite, collection_from::String, collection_to::String, label_collection_from::String, label_collection_to::String, relation_type::String)</code></pre><p>Set a scalar relation between two elements, linking an element from one collection to an element in another collection (or the same collection).</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the collection containing the element to set the relation from</li><li><code>collection_to::String</code>: The identifier of the collection containing the element to set the relation to</li><li><code>label_collection_from::String</code>: The label of the element to set the relation from</li><li><code>label_collection_to::String</code>: The label of the element to set the relation to</li><li><code>relation_type::String</code>: The type/name of the relation (e.g., &quot;id&quot;, &quot;turbine<em>to&quot;, &quot;spill</em>to&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the attribute is not a scalar relation</li><li><code>DatabaseException</code> if either element label doesn&#39;t exist</li><li><code>DatabaseException</code> if trying to set a relation between the same element (when both collections are the same)</li><li><code>DatabaseException</code> if the relation type doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Set a relation to a different collection
PSRDatabase.set_scalar_relation!(
    db,
    &quot;Plant&quot;,
    &quot;Resource&quot;,
    &quot;Plant 1&quot;,
    &quot;Resource 1&quot;,
    &quot;id&quot;,
)

# Set a relation within the same collection
PSRDatabase.set_scalar_relation!(
    db,
    &quot;Plant&quot;,
    &quot;Plant&quot;,
    &quot;Plant 3&quot;,
    &quot;Plant 1&quot;,
    &quot;turbine_to&quot;,
)

# Update an existing relation
PSRDatabase.set_scalar_relation!(
    db,
    &quot;Plant&quot;,
    &quot;Resource&quot;,
    &quot;Plant 1&quot;,
    &quot;Resource 2&quot;,  # Changes from Resource 1 to Resource 2
    &quot;id&quot;,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L356-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.set_time_series_file!-Tuple{PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.set_time_series_file!-Tuple{PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.set_time_series_file!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_time_series_file!(db::DatabaseSQLite, collection_id::String; kwargs...)</code></pre><p>Set or update time series file paths for a collection.</p><p>This function sets the file paths for time series attributes that store their data in external files. There can only be one set of time series files per collection.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection to set time series files for</li><li><code>kwargs...</code>: Named arguments where keys are time series file attribute names and values are file paths (strings)</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the collection doesn&#39;t exist</li><li><code>DatabaseException</code> if any attribute is not a time series file attribute</li><li><code>DatabaseException</code> if any value is not a string</li><li><code>DatabaseException</code> if there are multiple time series file entries (database corruption)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Set time series files for a collection
PSRDatabase.set_time_series_file!(
    db,
    &quot;Plant&quot;;
    generation = &quot;generation_data.csv&quot;,
    cost = &quot;cost_data.csv&quot;,
)

# Update a single time series file
PSRDatabase.set_time_series_file!(
    db,
    &quot;Plant&quot;;
    generation = &quot;new_generation_data.csv&quot;,
)

# Set multiple time series files at once
PSRDatabase.set_time_series_file!(
    db,
    &quot;Resource&quot;;
    availability = &quot;availability.txt&quot;,
    price = &quot;price.txt&quot;,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L707-L758">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.set_vector_relation!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Vector{String}, String}"><a class="docstring-binding" href="#PSRDatabase.set_vector_relation!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Vector{String}, String}"><code>PSRDatabase.set_vector_relation!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_vector_relation!(db::DatabaseSQLite, collection_from::String, collection_to::String, label_collection_from::String, labels_collection_to::Vector{String}, relation_type::String)</code></pre><p>Set a vector relation between an element and multiple elements, linking an element from one collection to multiple elements in another collection.</p><p>This function replaces all existing relations for the vector with the new relations provided.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_from::String</code>: The identifier of the collection containing the element to set the relation from</li><li><code>collection_to::String</code>: The identifier of the collection containing the elements to set the relation to</li><li><code>label_collection_from::String</code>: The label of the element to set the relation from</li><li><code>labels_collection_to::Vector{String}</code>: A vector of labels of elements to set the relation to</li><li><code>relation_type::String</code>: The type/name of the relation</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the attribute is not a vector relation</li><li><code>DatabaseException</code> if any element label doesn&#39;t exist</li><li><code>DatabaseException</code> if the relation type doesn&#39;t exist</li><li><code>DatabaseException</code> if the number of relations doesn&#39;t match other vectors in the same group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Set a vector relation
PSRDatabase.set_vector_relation!(
    db,
    &quot;Plant&quot;,
    &quot;Cost&quot;,
    &quot;Plant 1&quot;,
    [&quot;Cost 1&quot;, &quot;Cost 2&quot;],
    &quot;some_relation_type&quot;,
)

# Update vector relation with different elements
PSRDatabase.set_vector_relation!(
    db,
    &quot;Plant&quot;,
    &quot;Cost&quot;,
    &quot;Plant 1&quot;,
    [&quot;Cost 2&quot;, &quot;Cost 3&quot;, &quot;Cost 4&quot;],  # Now relates to 3 costs instead of 2
    &quot;some_relation_type&quot;,
)

# Clear all relations (empty vector)
PSRDatabase.set_vector_relation!(
    db,
    &quot;Plant&quot;,
    &quot;Cost&quot;,
    &quot;Plant 1&quot;,
    String[],
    &quot;some_relation_type&quot;,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L464-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.update_parameter!-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase.update_parameter!-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase.update_parameter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_parameter!(db::DatabaseSQLite, collection_id::String, label::String; kwargs...)</code></pre><p>Update multiple parameter attributes for a specific element in a collection. The function can update multiple types of parameters</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>label::String</code>: The label of the element to update</li><li><code>kwargs...</code>: Named arguments where keys are attribute names and values are the new values for those attributes</li></ul><p><strong>Returns</strong></p><pre><code class="language-julia hljs">- `nothing`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L17-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.update_scalar_parameter!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Any}"><a class="docstring-binding" href="#PSRDatabase.update_scalar_parameter!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Any}"><code>PSRDatabase.update_scalar_parameter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_scalar_parameter!(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String, val)</code></pre><p>Update the value of a scalar parameter attribute for a specific element in a collection.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>attribute_id::String</code>: The identifier of the scalar parameter attribute to update</li><li><code>label::String</code>: The label of the element to update</li><li><code>val</code>: The new value for the attribute (must match the attribute&#39;s type: Float64, Int64, String, or DateTime)</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the collection or attribute doesn&#39;t exist</li><li><code>DatabaseException</code> if the attribute is not a scalar parameter</li><li><code>DatabaseException</code> if the value type doesn&#39;t match the attribute type</li><li><code>DatabaseException</code> if the element label doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Update a string parameter
PSRDatabase.update_scalar_parameter!(db, &quot;Resource&quot;, &quot;type&quot;, &quot;Resource 1&quot;, &quot;D&quot;)

# Update a numeric parameter
PSRDatabase.update_scalar_parameter!(db, &quot;Resource&quot;, &quot;some_value_1&quot;, &quot;Resource 1&quot;, 1.0)

# Update a date parameter
PSRDatabase.update_scalar_parameter!(db, &quot;Configuration&quot;, &quot;date_initial&quot;, &quot;Toy Case&quot;, DateTime(2021, 1, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L66-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.update_time_series_row!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Any}"><a class="docstring-binding" href="#PSRDatabase.update_time_series_row!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Any}"><code>PSRDatabase.update_time_series_row!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_time_series_row!(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String, val; dimensions...)</code></pre><p>Update an existing value in a time series attribute for a specific element and dimension combination.</p><p>Unlike <code>add_time_series_row!</code>, this function only updates existing rows and will throw an error if the specified dimension combination doesn&#39;t exist.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>attribute_id::String</code>: The identifier of the time series attribute</li><li><code>label::String</code>: The label of the element to update the time series value for</li><li><code>val</code>: The new value for the time series at the specified dimensions</li><li><code>dimensions...</code>: Named arguments specifying the dimension values that identify the row to update</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the attribute is not a time series</li><li><code>DatabaseException</code> if the number of dimensions doesn&#39;t match the attribute definition</li><li><code>DatabaseException</code> if dimension names don&#39;t match the attribute definition</li><li><code>DatabaseException</code> if the specified dimension combination doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Update an existing time series value
PSRDatabase.update_time_series_row!(
    db,
    &quot;Plant&quot;,
    &quot;generation&quot;,
    &quot;Plant 1&quot;,
    150.0;
    date_time = DateTime(2020, 1, 1),
)

# Update with multiple dimensions
PSRDatabase.update_time_series_row!(
    db,
    &quot;Plant&quot;,
    &quot;cost&quot;,
    &quot;Plant 1&quot;,
    75.0;
    date_time = DateTime(2020, 1, 1),
    stage = 1,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L868-L920">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.update_vector_parameters!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Vector}"><a class="docstring-binding" href="#PSRDatabase.update_vector_parameters!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String, Vector}"><code>PSRDatabase.update_vector_parameters!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_vector_parameters!(db::DatabaseSQLite, collection_id::String, attribute_id::String, label::String, vals::Vector)</code></pre><p>Update all values of a vector parameter attribute for a specific element in a collection.</p><p>This function replaces all existing values for the vector with the new values provided.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>attribute_id::String</code>: The identifier of the vector parameter attribute to update</li><li><code>label::String</code>: The label of the element to update</li><li><code>vals::Vector</code>: A vector containing the new values (must match the attribute&#39;s type)</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the collection or attribute doesn&#39;t exist</li><li><code>DatabaseException</code> if the attribute is not a vector parameter</li><li><code>DatabaseException</code> if the value types don&#39;t match the attribute type</li><li><code>DatabaseException</code> if the element label doesn&#39;t exist</li><li><code>DatabaseException</code> if updating vectors in a group and the new length doesn&#39;t match other vectors in the group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Update a vector of numeric values
PSRDatabase.update_vector_parameters!(
    db,
    &quot;Resource&quot;,
    &quot;some_value_1&quot;,
    &quot;Resource 1&quot;,
    [10.0, 20.0, 30.0],
)

# Update to a different number of values (if not constrained by vector group)
PSRDatabase.update_vector_parameters!(
    db,
    &quot;Resource&quot;,
    &quot;some_value_1&quot;,
    &quot;Resource 1&quot;,
    [5.0, 15.0],
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/update.jl#L144-L192">source</a></section></details></article><h2 id="Delete-Functions"><a class="docs-heading-anchor" href="#Delete-Functions">Delete Functions</a><a id="Delete-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.delete_element!-Tuple{PSRDatabase.DatabaseSQLite, String, Integer}"><a class="docstring-binding" href="#PSRDatabase.delete_element!-Tuple{PSRDatabase.DatabaseSQLite, String, Integer}"><code>PSRDatabase.delete_element!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">delete_element!(db::DatabaseSQLite, collection_id::String, id::Integer)</code></pre><p>Delete an element from a collection by its numeric ID.</p><p>This function removes an element and all its associated data from the database. Due to CASCADE DELETE foreign key constraints, any references to this element from other collections will also be deleted.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>id::Integer</code>: The numeric ID of the element to delete</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Delete an element by ID
PSRDatabase.delete_element!(db, &quot;Plant&quot;, 3)

# Typically used internally after looking up an ID from a label
id = PSRDatabase._get_id(db, &quot;Plant&quot;, &quot;Plant 1&quot;)
PSRDatabase.delete_element!(db, &quot;Plant&quot;, id)</code></pre><p><strong>See Also</strong></p><ul><li><code>delete_element!(db, collection_id, label)</code>: Delete by label instead of numeric ID</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/delete.jl#L53-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.delete_element!-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><a class="docstring-binding" href="#PSRDatabase.delete_element!-Tuple{PSRDatabase.DatabaseSQLite, String, String}"><code>PSRDatabase.delete_element!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">delete_element!(db::DatabaseSQLite, collection_id::String, label::String)</code></pre><p>Delete an element from a collection by its label.</p><p>This function removes an element and all its associated data from the database. Due to CASCADE DELETE foreign key constraints, any references to this element from other collections will also be deleted.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>label::String</code>: The label of the element to delete</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the collection doesn&#39;t exist</li><li><code>DatabaseException</code> if the element label doesn&#39;t exist</li><li><code>SQLiteException</code> if the deletion violates database constraints (e.g., foreign key without cascade)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Delete an element by label
PSRDatabase.delete_element!(db, &quot;Plant&quot;, &quot;Plant 3&quot;)

# After deletion, the same label can be reused
PSRDatabase.create_element!(db, &quot;Plant&quot;; label = &quot;Plant 3&quot;, capacity = 100.0)

# Deleting an element that has relations will also delete those relations
PSRDatabase.delete_element!(db, &quot;Resource&quot;, &quot;Resource 1&quot;)  # Also removes Plant-&gt;Resource relations</code></pre><p><strong>See Also</strong></p><ul><li><code>delete_element!(db, collection_id, id)</code>: Delete by numeric ID instead of label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/delete.jl#L1-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.delete_time_series!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><a class="docstring-binding" href="#PSRDatabase.delete_time_series!-Tuple{PSRDatabase.DatabaseSQLite, String, String, String}"><code>PSRDatabase.delete_time_series!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">delete_time_series!(db::DatabaseSQLite, collection_id::String, group_id::String, label::String)</code></pre><p>Delete all time series data for a specific element in a time series group.</p><p>This function removes all rows from the time series table for a given element, effectively deleting all time series values across all dimensions for that element and group.</p><p><strong>Arguments</strong></p><ul><li><code>db::DatabaseSQLite</code>: The database connection</li><li><code>collection_id::String</code>: The identifier of the collection containing the element</li><li><code>group_id::String</code>: The identifier of the time series group</li><li><code>label::String</code>: The label of the element to delete time series data for</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the collection doesn&#39;t exist</li><li><code>DatabaseException</code> if the element label doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Delete all time series data for an element in a specific group
PSRDatabase.delete_time_series!(db, &quot;Plant&quot;, &quot;generation_group&quot;, &quot;Plant 1&quot;)

# After deletion, you can add new time series data for the same element
PSRDatabase.add_time_series_row!(
    db,
    &quot;Plant&quot;,
    &quot;generation&quot;,
    &quot;Plant 1&quot;,
    100.0;
    date_time = DateTime(2021, 1, 1),
)</code></pre><p><strong>Notes</strong></p><p>This function only deletes time series data, not the element itself. To delete the entire element, use <code>delete_element!</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/delete.jl#L114-L159">source</a></section></details></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.create_empty_db_from_migrations-Tuple{String, String}"><a class="docstring-binding" href="#PSRDatabase.create_empty_db_from_migrations-Tuple{String, String}"><code>PSRDatabase.create_empty_db_from_migrations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_empty_db_from_migrations(database_path::String, path_migrations::String; force::Bool = false)</code></pre><p>Create a new empty database by applying migration files.</p><p>This function creates a new SQLite database file and applies all migration files found in the specified directory to build up the database structure incrementally.</p><p><strong>Arguments</strong></p><ul><li><code>database_path::String</code>: The file path where the database will be created</li><li><code>path_migrations::String</code>: The path to the directory containing migration SQL files</li><li><code>force::Bool</code>: If <code>true</code>, overwrites an existing database file at the same path. If <code>false</code> (default), throws an error if the file already exists</li></ul><p><strong>Returns</strong></p><ul><li><code>DatabaseSQLite</code>: A database connection object to the newly created database</li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the database file already exists and <code>force=false</code></li><li><code>DatabaseException</code> if the migrations directory is not found or migrations are invalid</li><li><code>DatabaseException</code> if the resulting database structure is invalid</li><li><code>SQLiteException</code> if SQL statements in migrations are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a new database from migrations
db = PSRDatabase.create_empty_db_from_migrations(
    &quot;my_database.sqlite&quot;,
    &quot;migrations/&quot;,
)

# Overwrite existing database
db = PSRDatabase.create_empty_db_from_migrations(
    &quot;my_database.sqlite&quot;,
    &quot;migrations/&quot;;
    force = true,
)</code></pre><p><strong>See Also</strong></p><ul><li><code>create_empty_db_from_schema</code>: Create database from a single schema file</li><li><code>load_db</code>: Load and migrate an existing database</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/utils.jl#L105-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.create_empty_db_from_schema-Tuple{String, String}"><a class="docstring-binding" href="#PSRDatabase.create_empty_db_from_schema-Tuple{String, String}"><code>PSRDatabase.create_empty_db_from_schema</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_empty_db_from_schema(database_path::String, path_schema::String; force::Bool = false)</code></pre><p>Create a new empty database from a SQL schema file.</p><p>This function creates a new SQLite database file and executes all SQL statements from the schema file to set up the database structure (tables, constraints, etc.).</p><p><strong>Arguments</strong></p><ul><li><code>database_path::String</code>: The file path where the database will be created</li><li><code>path_schema::String</code>: The path to the SQL schema file containing CREATE TABLE statements</li><li><code>force::Bool</code>: If <code>true</code>, overwrites an existing database file at the same path. If <code>false</code> (default), throws an error if the file already exists</li></ul><p><strong>Returns</strong></p><ul><li><code>DatabaseSQLite</code>: A database connection object to the newly created database</li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the database file already exists and <code>force=false</code></li><li><code>DatabaseException</code> if the schema file is not found</li><li><code>DatabaseException</code> if the database structure is invalid (e.g., missing Configuration table)</li><li><code>SQLiteException</code> if SQL statements in the schema are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a new database from a schema file
db = PSRDatabase.create_empty_db_from_schema(
    &quot;my_database.sqlite&quot;,
    &quot;schema.sql&quot;,
)

# Overwrite existing database
db = PSRDatabase.create_empty_db_from_schema(
    &quot;my_database.sqlite&quot;,
    &quot;schema.sql&quot;;
    force = true,
)</code></pre><p><strong>See Also</strong></p><ul><li><code>create_empty_db_from_migrations</code>: Create database using migration files</li><li><code>load_db</code>: Load an existing database</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/utils.jl#L41-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.execute_statements-Tuple{SQLite.DB, String}"><a class="docstring-binding" href="#PSRDatabase.execute_statements-Tuple{SQLite.DB, String}"><code>PSRDatabase.execute_statements</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">execute_statements(db::SQLite.DB, file::String)</code></pre><p>Execute all statements in a .sql file against a database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/utils.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.load_db-Tuple{String, String}"><a class="docstring-binding" href="#PSRDatabase.load_db-Tuple{String, String}"><code>PSRDatabase.load_db</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_db(database_path::String, path_migrations::String)</code></pre><p>Load an existing database and apply any pending migrations.</p><p>Opens a connection to an existing SQLite database file and applies any migration files that haven&#39;t been applied yet.</p><p><strong>Arguments</strong></p><ul><li><code>database_path::String</code>: The file path to the database to load</li><li><code>path_migrations::String</code>: The path to the directory containing migration SQL files</li></ul><p><strong>Returns</strong></p><ul><li><code>DatabaseSQLite</code>: A database connection object with all migrations applied</li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the database file doesn&#39;t exist</li><li><code>DatabaseException</code> if migrations are invalid or cannot be applied</li><li><code>SQLiteException</code> if the file is not a valid SQLite database or migration SQL is invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Load a database and apply pending migrations
db = PSRDatabase.load_db(&quot;my_database.sqlite&quot;, &quot;migrations/&quot;)

# Work with the database
labels = PSRDatabase.read_scalar_parameters(db, &quot;Plant&quot;, &quot;label&quot;)

# Close when done
PSRDatabase.close!(db)</code></pre><p><strong>See Also</strong></p><ul><li><code>load_db(database_path; read_only)</code>: Load without applying migrations</li><li><code>create_empty_db_from_migrations</code>: Create new database with migrations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/utils.jl#L222-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.load_db-Tuple{String}"><a class="docstring-binding" href="#PSRDatabase.load_db-Tuple{String}"><code>PSRDatabase.load_db</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_db(database_path::String; read_only::Bool = false)</code></pre><p>Load an existing database from a file.</p><p>Opens a connection to an existing SQLite database file. The database structure is validated and metadata is loaded into memory for fast access.</p><p><strong>Arguments</strong></p><ul><li><code>database_path::String</code>: The file path to the database to load</li><li><code>read_only::Bool</code>: If <code>true</code>, opens the database in read-only mode (immutable). If <code>false</code> (default), opens with read-write access</li></ul><p><strong>Returns</strong></p><ul><li><code>DatabaseSQLite</code>: A database connection object</li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if the database file doesn&#39;t exist</li><li><code>DatabaseException</code> if the database structure is invalid</li><li><code>SQLiteException</code> if the file is not a valid SQLite database</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Load a database with read-write access
db = PSRDatabase.load_db(&quot;my_database.sqlite&quot;)

# Load a database in read-only mode
db = PSRDatabase.load_db(&quot;my_database.sqlite&quot;; read_only = true)

# Use the database and close when done
PSRDatabase.close!(db)</code></pre><p><strong>See Also</strong></p><ul><li><code>load_db(database_path, path_migrations)</code>: Load and apply migrations</li><li><code>create_empty_db_from_schema</code>: Create a new database</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/utils.jl#L169-L209">source</a></section></details></article><h2 id="Validation-Functions"><a class="docs-heading-anchor" href="#Validation-Functions">Validation Functions</a><a id="Validation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Validation-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase._validate_database_pragmas-Tuple{SQLite.DB}"><a class="docstring-binding" href="#PSRDatabase._validate_database_pragmas-Tuple{SQLite.DB}"><code>PSRDatabase._validate_database_pragmas</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_database_pragmas(db::SQLite.DB)</code></pre><p>Internal function to validate that required SQLite pragmas are properly set in the database.</p><p>Currently validates:</p><ul><li>User version must be defined and not set to zero</li></ul><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: The SQLite database connection to validate</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DatabaseException</code> if user_version is 0 or not defined</li></ul><p><strong>Notes</strong></p><p>This is an internal validation function used during database loading to ensure the database has proper version information. The user_version pragma is used for schema versioning and migrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/validate.jl#L642-L667">source</a></section></details></article><h2 id="Automatic-Docstring-Generation"><a class="docs-heading-anchor" href="#Automatic-Docstring-Generation">Automatic Docstring Generation</a><a id="Automatic-Docstring-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Docstring-Generation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.GroupMap"><a class="docstring-binding" href="#PSRDatabase.GroupMap"><code>PSRDatabase.GroupMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GroupMap</code></pre><p>Internal struct to store information about a time series group for docstring generation.</p><p><strong>Fields</strong></p><ul><li><code>group_id::String</code>: The identifier of the time series group</li><li><code>parameters::Vector{TimeSeries{&lt;:Number}}</code>: Vector of time series parameters in the group</li><li><code>dimensions::Vector{String}</code>: Names of the dimensions for this time series group</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/docstrings.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.collection_docstring-Tuple{String, String}"><a class="docstring-binding" href="#PSRDatabase.collection_docstring-Tuple{String, String}"><code>PSRDatabase.collection_docstring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">collection_docstring(model_folder::String, collection::String; ignore_id::Bool = true)</code></pre><p>Generate automatic documentation for a collection&#39;s attributes.</p><p>This function creates documentation text that lists all required and optional parameters,  vector attributes, relations, and time series for a specific collection in a PSR model. It reads the database schema from migrations and attribute metadata from TOML files.</p><p><strong>Arguments</strong></p><ul><li><code>model_folder::String</code>: Path to the model directory containing migrations and UI metadata</li><li><code>collection::String</code>: Name of the collection to document</li><li><code>ignore_id::Bool</code>: If <code>true</code> (default), excludes the <code>id</code> field from documentation</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Formatted documentation string with all collection attributes</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Use in a model-specific add function to automatically generate parameter documentation
&quot;&quot;&quot;
    add_hydro_unit!(db::DatabaseSQLite; kwargs...)

Add a Hydro Unit to the database.

# Arguments
$(PSRDatabase.collection_docstring(model_directory(), &quot;HydroUnit&quot;))

# Examples
    db = PSRDatabase.load_db(&quot;path/to/model.db&quot;)
    add_hydro_unit!(
        db;
        label = &quot;Plant1&quot;,
        initial_volume = 100.0,
    )
&quot;&quot;&quot;
function add_hydro_unit!(db::DatabaseSQLite; kwargs...)
    PSRDatabase.create_element!(db, &quot;HydroUnit&quot;; kwargs...)
end</code></pre><p><strong>Notes</strong></p><p>Creates a temporary database from migrations to extract schema information. The temporary database is automatically cleaned up after generating the docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/docstrings.jl#L223-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.time_series_files_docstrings"><a class="docstring-binding" href="#PSRDatabase.time_series_files_docstrings"><code>PSRDatabase.time_series_files_docstrings</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">time_series_files_docstrings(model_folder::String, ignore_id::Bool = true)</code></pre><p>Generate documentation for all time series file attributes across all collections.</p><p>This function creates documentation text listing all time series file attributes organized by collection. It reads the database schema from migrations and attribute metadata from TOML files.</p><p><strong>Arguments</strong></p><ul><li><code>model_folder::String</code>: Path to the model directory containing migrations and UI metadata</li><li><code>ignore_id::Bool</code>: If <code>true</code> (default), excludes the <code>id</code> field from documentation</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Formatted documentation string with all time series file attributes organized by collection</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Use in a model&#39;s link function to automatically document available time series files
&quot;&quot;&quot;
    link_time_series_to_file(db::DatabaseSQLite, table_name::String; kwargs...)

Links a time series to a file in the database.

Each collection in the database can be linked to different time series files.

The possible files for each collection are:

$(PSRDatabase.time_series_files_docstrings(model_directory()))

# Examples
    db = PSRDatabase.load_db(&quot;path/to/model.db&quot;)
    link_time_series_to_file(
        db,
        &quot;HydroUnit&quot;;
        file_path = &quot;generation.csv&quot;,
    )
&quot;&quot;&quot;
function link_time_series_to_file(db::DatabaseSQLite, table_name::String; kwargs...)
    PSRDatabase.set_time_series_file!(db, table_name; kwargs...)
end</code></pre><p><strong>Notes</strong></p><p>Creates a temporary database from migrations to extract schema information. The temporary database is automatically cleaned up after generating the docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/docstrings.jl#L357-L403">source</a></section></details></article><h2 id="Comparing-Databases"><a class="docs-heading-anchor" href="#Comparing-Databases">Comparing Databases</a><a id="Comparing-Databases-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-Databases" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_databases-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite}"><a class="docstring-binding" href="#PSRDatabase.compare_databases-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite}"><code>PSRDatabase.compare_databases</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_databases(db1::DatabaseSQLite, db2::DatabaseSQLite)</code></pre><p>Compare two databases to ensure they have the same data across all collections.</p><p>This function performs a comprehensive comparison of two PSRDatabase databases by iterating through all collections and comparing their:</p><ul><li>Number of elements</li><li>Scalar parameters</li><li>Vector parameters</li><li>Scalar relations</li><li>Vector relations</li><li>Set parameters</li><li>Set relations</li><li>Time series data</li><li>Time series file references</li></ul><p>The comparison is thorough and identifies specific differences at the element, attribute, and value level, making it useful for validating database migrations, testing database operations, or ensuring data consistency after transformations.</p><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare</li><li><code>db2::DatabaseSQLite</code>: The second database to compare</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing all differences found. Each string is a human-readable error message that identifies:</p><ul><li>The collection where the difference was found</li><li>The attribute or data type being compared</li><li>The specific element (by index or label)</li><li>The exact values that differ</li></ul><p>If the databases are completely identical, returns an empty vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Compare two identical databases
db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

create_element!(db1, &quot;Configuration&quot;; label = &quot;Config1&quot;, value1 = 100.0)
create_element!(db2, &quot;Configuration&quot;; label = &quot;Config1&quot;, value1 = 100.0)

differences = compare_databases(db1, db2)
# Returns: []

# Compare databases with differences
db3 = create_empty_db_from_schema(&quot;db3.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db4 = create_empty_db_from_schema(&quot;db4.sqlite&quot;, &quot;schema.sql&quot;; force = true)

create_element!(db3, &quot;Configuration&quot;; label = &quot;Config1&quot;, value1 = 100.0)
create_element!(db4, &quot;Configuration&quot;; label = &quot;Config1&quot;, value1 = 200.0)

differences = compare_databases(db3, db4)
# Returns: [&quot;Collection &#39;Configuration&#39;, attribute &#39;value1&#39;, element 1: values differ (db1: 100.0, db2: 200.0)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L785-L845">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_scalar_parameters-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_scalar_parameters-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_scalar_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_scalar_parameters(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare scalar parameters between two databases for a specific collection.</p><p>This function iterates through all scalar parameters (excluding the id field) in the specified collection and compares their values element-by-element between the two databases. It checks for differences in the number of elements, null values, and actual value mismatches.</p><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare scalar parameters for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in scalar parameters. Each string includes the collection name, attribute name, element index, and the differing values. Returns an empty vector if all scalar parameters are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

create_element!(db1, &quot;Configuration&quot;; label = &quot;Config1&quot;, value1 = 100.0)
create_element!(db2, &quot;Configuration&quot;; label = &quot;Config1&quot;, value1 = 200.0)

differences = compare_scalar_parameters(db1, db2, &quot;Configuration&quot;)
# Returns: [&quot;Collection &#39;Configuration&#39;, attribute &#39;value1&#39;, element 1: values differ (db1: 100.0, db2: 200.0)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L1-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_scalar_relations-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_scalar_relations-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_scalar_relations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_scalar_relations(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare scalar relations between two databases for a specific collection.</p><p>This function iterates through all scalar relations (foreign key references to other collections) in the specified collection and compares them element-by-element between the two databases. It verifies that each element points to the same related element in both databases.</p><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare scalar relations for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in scalar relations. Each string includes the collection name, relation attribute name, target collection name, element index, and the labels of the related elements that differ. Returns an empty vector if all scalar relations are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

# Create resources
create_element!(db1, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;)
create_element!(db1, &quot;Resource&quot;; label = &quot;Resource2&quot;, type = &quot;E&quot;)
create_element!(db2, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;)
create_element!(db2, &quot;Resource&quot;; label = &quot;Resource2&quot;, type = &quot;E&quot;)

# Create plants with different scalar relations
create_element!(db1, &quot;Plant&quot;; label = &quot;Plant1&quot;, capacity = 100.0)
create_element!(db2, &quot;Plant&quot;; label = &quot;Plant1&quot;, capacity = 100.0)
set_scalar_relation!(db1, &quot;Plant&quot;, &quot;Resource&quot;, &quot;Plant1&quot;, &quot;Resource1&quot;, &quot;id&quot;)
set_scalar_relation!(db2, &quot;Plant&quot;, &quot;Resource&quot;, &quot;Plant1&quot;, &quot;Resource2&quot;, &quot;id&quot;)

differences = compare_scalar_relations(db1, db2, &quot;Plant&quot;)
# Returns: [&quot;Collection &#39;Plant&#39;, scalar relation &#39;resource_id&#39; to &#39;Resource&#39;, element 1: relations differ (db1: Resource1, db2: Resource2)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L170-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_set_parameters-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_set_parameters-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_set_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_set_parameters(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare set parameters between two databases for a specific collection.</p><p>This function iterates through all set parameters in the specified collection and compares the sets of values for each element between the two databases. For each set attribute, it checks:</p><ul><li>The number of elements in the collection</li><li>The size of each set</li><li>The values within each set (order-independent comparison)</li></ul><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare set parameters for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in set parameters. Each string includes the collection name, set attribute name, element index, and the differing set contents. Returns an empty vector if all set parameters are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

# Create elements with different set parameter values (provided as arrays)
create_element!(db1, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;, some_set_value1 = [1.0, 2.0], some_set_value2 = [5.0, 4.0])
create_element!(db2, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;, some_set_value1 = [1.0, 2.0], some_set_value2 = [5.0, 6.0])

differences = compare_set_parameters(db1, db2, &quot;Resource&quot;)
# Returns: [&quot;Collection &#39;Resource&#39;, set attribute &#39;some_set_value2&#39;, element 2: sets differ (db1: 4.0, db2: 6.0)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L566-L602">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_set_relations-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_set_relations-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_set_relations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_set_relations(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare set relations between two databases for a specific collection.</p><p>This function iterates through all set relations (sets of foreign key references to other collections) in the specified collection and compares them element-by-element between the two databases. For each set relation, it checks:</p><ul><li>The number of elements in the collection</li><li>The size of each relation set</li><li>Individual relation references within each set (order-independent comparison)</li></ul><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare set relations for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in set relations. Each string includes the collection name, set relation attribute name, target collection name, element index, and the labels of the related elements that differ. Returns an empty vector if all set relations are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

# Create costs
for (db, label, value) in [(db1, &quot;Cost1&quot;, 10.0), (db1, &quot;Cost2&quot;, 20.0), (db1, &quot;Cost3&quot;, 30.0),
                            (db2, &quot;Cost1&quot;, 10.0), (db2, &quot;Cost2&quot;, 20.0), (db2, &quot;Cost3&quot;, 30.0)]
    create_element!(db, &quot;Cost&quot;; label = label, value = value)
end

# Create resources with different set relations (provided as separate arrays)
create_element!(db1, &quot;Resource&quot;; label = &quot;Resource1&quot;, some_set_factor = [1.0, 2.0], cost_id = [&quot;Cost1&quot;, &quot;Cost2&quot;])
create_element!(db2, &quot;Resource&quot;; label = &quot;Resource1&quot;, some_set_factor = [1.0, 2.0], cost_id = [&quot;Cost1&quot;, &quot;Cost3&quot;])

differences = compare_set_relations(db1, db2, &quot;Resource&quot;)
# Returns: [&quot;Collection &#39;Resource&#39;, set relation &#39;cost_id&#39; to &#39;Cost&#39;, element 1, set index 2: relation sets differ (db1: Cost2, db2: Cost3)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L667-L710">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_time_series-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_time_series-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_time_series</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_time_series(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare time series data between two databases for a specific collection.</p><p>This function iterates through all time series attributes in the specified collection, grouped by their group_id, and compares the data for each element between the two databases. For each time series, it checks:</p><ul><li>The size of the time series tables (number of rows and columns)</li><li>The column names and their order</li><li>Individual values in each cell of the time series data</li></ul><p>The comparison handles missing values and null values appropriately, ensuring that null states match between databases.</p><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure and element labels)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare time series data for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in time series data. Each string includes the collection name, time series attribute name, element label, column name, row index, and the differing values. Returns an empty vector if all time series data is identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DataFrames, Dates

db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

df1 = DataFrame(
    date_time = [DateTime(2020), DateTime(2021), DateTime(2022)],
    some_vector1 = [1.0, 2.0, 3.0],
    some_vector2 = [10.0, 20.0, 30.0],
)
df2 = DataFrame(
    date_time = [DateTime(2020), DateTime(2021), DateTime(2022)],
    some_vector1 = [1.0, 5.0, 3.0],
    some_vector2 = [10.0, 20.0, 30.0],
)

create_element!(db1, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;, group1 = df1)
create_element!(db2, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;, group1 = df2)

differences = compare_time_series(db1, db2, &quot;Resource&quot;)
# Returns: [&quot;Collection &#39;Resource&#39;, time series &#39;some_vector1&#39;, label &#39;Resource1&#39;, column &#39;some_vector1&#39;, row 2: values differ (db1: 2.0, db2: 5.0)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L356-L408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_time_series_files-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_time_series_files-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_time_series_files</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_time_series_files(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare time series file paths between two databases for a specific collection.</p><p>This function compares the file paths stored in the time<em>series</em>files table for each element in the specified collection. It checks whether file paths are present in one database but not the other, and whether the file paths match when present in both databases.</p><p>Note that this function only compares the file path strings stored in the database, not the contents of the files themselves.</p><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure and element labels)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare time series file references for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in time series file paths. Each string includes the collection name, time series file attribute name, and information about whether file paths are missing or differ between databases. Returns an empty vector if all time series file references are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

create_element!(db1, &quot;Plant&quot;; label = &quot;Plant1&quot;, capacity = 100.0)
create_element!(db2, &quot;Plant&quot;; label = &quot;Plant1&quot;, capacity = 100.0)

set_time_series_file!(db1, &quot;Plant&quot;; generation = &quot;generation1.csv&quot;)
set_time_series_file!(db2, &quot;Plant&quot;; generation = &quot;generation2.csv&quot;)

differences = compare_time_series_files(db1, db2, &quot;Plant&quot;)
# Returns: [&quot;Collection &#39;Plant&#39;, time series file &#39;generation&#39;: file paths differ (db1: generation1.csv, db2: generation2.csv)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L485-L525">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_vector_parameters-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_vector_parameters-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_vector_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_vector_parameters(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare vector parameters between two databases for a specific collection.</p><p>This function iterates through all vector parameters in the specified collection and compares their values element-by-element between the two databases. For each vector attribute, it checks:</p><ul><li>The number of elements in the collection</li><li>The length of each vector</li><li>Individual values within each vector</li></ul><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare vector parameters for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in vector parameters. Each string includes the collection name, vector attribute name, element index, vector index, and the differing values. Returns an empty vector if all vector parameters are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

create_element!(db1, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;, some_value1 = [1.0, 2.0, 3.0])
create_element!(db2, &quot;Resource&quot;; label = &quot;Resource1&quot;, type = &quot;D&quot;, some_value1 = [1.0, 5.0, 3.0])

differences = compare_vector_parameters(db1, db2, &quot;Resource&quot;)
# Returns: [&quot;Collection &#39;Resource&#39;, vector attribute &#39;some_value1&#39;, element 1, index 2: values differ (db1: 2.0, db2: 5.0)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L82-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PSRDatabase.compare_vector_relations-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><a class="docstring-binding" href="#PSRDatabase.compare_vector_relations-Tuple{PSRDatabase.DatabaseSQLite, PSRDatabase.DatabaseSQLite, String}"><code>PSRDatabase.compare_vector_relations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_vector_relations(db1::DatabaseSQLite, db2::DatabaseSQLite, collection_id::String)</code></pre><p>Compare vector relations between two databases for a specific collection.</p><p>This function iterates through all vector relations (arrays of foreign key references to other collections) in the specified collection and compares them element-by-element between the two databases. For each vector relation, it checks:</p><ul><li>The number of elements in the collection</li><li>The length of each relation vector</li><li>Individual relation references within each vector</li></ul><p><strong>Arguments</strong></p><ul><li><code>db1::DatabaseSQLite</code>: The first database to compare (used as the reference for reading collection structure)</li><li><code>db2::DatabaseSQLite</code>: The second database to compare against the first</li><li><code>collection_id::String</code>: The name of the collection (table) to compare vector relations for</li></ul><p><strong>Returns</strong></p><p>A vector of strings describing differences found in vector relations. Each string includes the collection name, vector relation attribute name, target collection name, element index, vector index, and the labels of the related elements that differ. Returns an empty vector if all vector relations are identical.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">db1 = create_empty_db_from_schema(&quot;db1.sqlite&quot;, &quot;schema.sql&quot;; force = true)
db2 = create_empty_db_from_schema(&quot;db2.sqlite&quot;, &quot;schema.sql&quot;; force = true)

# Create costs
for (db, label, value) in [(db1, &quot;Cost1&quot;, 10.0), (db1, &quot;Cost2&quot;, 20.0), (db1, &quot;Cost3&quot;, 30.0),
                            (db2, &quot;Cost1&quot;, 10.0), (db2, &quot;Cost2&quot;, 20.0), (db2, &quot;Cost3&quot;, 30.0)]
    create_element!(db, &quot;Cost&quot;; label = label, value = value)
end

# Create plants with different vector relations
create_element!(db1, &quot;Plant&quot;; label = &quot;Plant1&quot;, capacity = 100.0, some_factor = [1.0, 2.0])
create_element!(db2, &quot;Plant&quot;; label = &quot;Plant1&quot;, capacity = 100.0, some_factor = [1.0, 2.0])
set_vector_relation!(db1, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant1&quot;, [&quot;Cost1&quot;, &quot;Cost2&quot;], &quot;id&quot;)
set_vector_relation!(db2, &quot;Plant&quot;, &quot;Cost&quot;, &quot;Plant1&quot;, [&quot;Cost1&quot;, &quot;Cost3&quot;], &quot;id&quot;)

differences = compare_vector_relations(db1, db2, &quot;Plant&quot;)
# Returns: [&quot;Collection &#39;Plant&#39;, vector relation &#39;cost_id&#39; to &#39;Cost&#39;, element 1, index 2: relations differ (db1: Cost2, db2: Cost3)&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psrenergy/PSRDatabase.jl/blob/43bb314f6aa18037bedab13ad462a3fc327c4e14/src/compare_dbs.jl#L256-L302">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sqlite_examples/migrations/">« Migration Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 11 December 2025 18:33">Thursday 11 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
